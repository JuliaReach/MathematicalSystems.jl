var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#Internals-1","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"lib/internals/#","page":"Internals","title":"Internals","text":"This section describes functions that are internal to the library.","category":"page"},{"location":"lib/internals/#","page":"Internals","title":"Internals","text":"Pages = [\"internals.md\"]\nDepth = 3","category":"page"},{"location":"lib/internals/#","page":"Internals","title":"Internals","text":"CurrentModule = MathematicalSystems\nDocTestSetup = quote\n    using MathematicalSystems\nend","category":"page"},{"location":"lib/internals/#Expression-handling-1","page":"Internals","title":"Expression handling","text":"","category":"section"},{"location":"lib/internals/#","page":"Internals","title":"Internals","text":"_corresponding_type\n_capture_dim\nextract_dyn_equation_parameters\nadd_asterisk\nsort","category":"page"},{"location":"lib/internals/#MathematicalSystems._corresponding_type","page":"Internals","title":"MathematicalSystems._corresponding_type","text":"_corresponding_type(AT::Type{<:AbstractSystem}, fields::Tuple)\n\nReturn the system type whose field names match those in fields.\n\nInput\n\nAT     – abstract system type, which can be either AbstractContinuousSystem             or AbstractDiscreSystem\nfields – tuple of field names\n\nOutput\n\nThe system type (either discrete or continous, depending on AT) whose fields names correspond to those in fields, or an error if the fields do not match any known system type.\n\nExamples\n\njulia> using MathematicalSystems: _corresponding_type\n\njulia> _corresponding_type(AbstractContinuousSystem, ((:A),))\nLinearContinuousSystem\n\njulia> _corresponding_type(AbstractContinuousSystem, ((:A), (:B), (:X), (:U)))\nConstrainedLinearControlContinuousSystem\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MathematicalSystems._capture_dim","page":"Internals","title":"MathematicalSystems._capture_dim","text":"_capture_dim(expr)\n\nReturn the tuple containing the dimension(s) in expr.\n\nInput\n\nexpr – symbolic expression that can be of any of the following forms:\n:x or :(x) – state dimension\n:(x, u)      – state and input dimension\n:(x, u, w)   – state, input and noise dimensions\n\nOutput\n\nThe scalar x if expr specifies the state dimension.\nThe vector [x, u] if expr specifies state and input dimension.\nThe vector [x, u, w] if expr specifies state, input and noise dimensions.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MathematicalSystems.extract_dyn_equation_parameters","page":"Internals","title":"MathematicalSystems.extract_dyn_equation_parameters","text":"extract_dyn_equation_parameters(equation, state, input, noise, dim, AT)\n\nExtract the value and field parameter from the dynamic equation equation according to the variable state, input and noise.\n\nFor the right-hand side of the dynamic equation, this function returns a vector of tuples containing some elements from the list\n\n(:A_user, :A)\n(:B_user, :B)\n(:c_user, :c)\n(:D_user, :D)\n(:f_user, :f)\n(:statedim_user :statedim)\n(:inputdim_user :inputdim)\n(:noisedim_user :noisedim)\n\nand for the left-hand side, it returns either an empty vector Any[] or [(:E_user, :E)] where the first argument of the tuple corresponds to the value and the second argument of the tuple corresponds to the field parameter.\n\nInput\n\nequation – dynamic equation\nstate    – state variable\ninput    – input variable\nnoise    – noise variable\ndim      – dimensionality\nAT       – abstract system type\n\nOutput\n\nTwo arrays of tuples containing the value and field parameters for the right-hand and left-hand side of the dynamic equation equation.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MathematicalSystems.add_asterisk","page":"Internals","title":"MathematicalSystems.add_asterisk","text":"add_asterisk(summand, state::Symbol, input::Symbol, noise::Symbol)\n\nChecks if expression summand contains state, input or noise at its end. If so, a multiplication expression, e.g. Expr(:call, :*, :A, :x) is created. If not,summand` is returned.\n\nInput\n\nsummand – expressions\nstate   – state variable\ninput   – input variable\nnoise   – noise variable\n\nOutput\n\nMultiplication expression or symbol.\n\nExample\n\njulia> using MathematicalSystems: add_asterisk\n\njulia> add_asterisk(:(A1*x), :x, :u, :w)\n:(A1 * x)\n\njulia> add_asterisk(:(c1), :x, :u, :w)\n:c1\n\njulia> add_asterisk(:(Ax1), :x1, :u, :w)\n:(A * x1)\n\njulia> add_asterisk(:(Awb), :x1, :u, :wb)\n:(A * wb)\n\njulia> add_asterisk(:(A1u), :x, :u, :w)\n:(A1 * u)\n\njulia> add_asterisk(:(A1ub), :x, :u, :w)\n:A1ub\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Base.sort","page":"Internals","title":"Base.sort","text":"sort(parameters::Vector, order::Tuple)\n\nFilter and sort the vector parameters according to order.\n\nInput\n\nparameters – vector of tuples\norder      – tuple of symbols\n\nOutput\n\nA new vector of tuples corresponding to parameters filtered and sorted according to order.\n\nExamples\n\njulia> parameters= [(:U1, :U), (:X1, :X), (:W1, :W)];\n\njulia> sort(parameters, (:X, :U, :W))\n3-element Array{Tuple{Any,Symbol},1}:\n (:X1, :X)\n (:U1, :U)\n (:W1, :W)\n\njulia>  parameters = [(:const, :c), (:A, :A)];\n\njulia> sort(parameters, (:A, :B, :c, :D))\n2-element Array{Tuple{Any,Symbol},1}:\n (:A, :A)\n (:const, :c)\n\nNotes\n\nparameters is a vector that contains tuples whose second element is considered for the sorting according to order.\n\nIf a value of order is not contained in parameters, the corresponding entry of order will be omitted.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Querying-expressions-1","page":"Internals","title":"Querying expressions","text":"","category":"section"},{"location":"lib/internals/#","page":"Internals","title":"Internals","text":"is_equation\nextract_sum","category":"page"},{"location":"lib/internals/#MathematicalSystems.is_equation","page":"Internals","title":"MathematicalSystems.is_equation","text":"is_equation(expr)\n\nReturn true if the given expression expr corresponds to an equation lhs = rhs and false otherwise. This function just detects the presence of the symbol =.\n\nInput\n\nexpr – expression\n\nOutput\n\nA Bool indicating whether expr is an equation or not.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#MathematicalSystems.extract_sum","page":"Internals","title":"MathematicalSystems.extract_sum","text":"extract_sum(summands, state::Symbol, input::Symbol, noise::Symbol)\n\nExtract the variable name and field name for every element of summands which corresponds to the elements of the right-hand side of an affine system.\n\nInput\n\nsummands – array of expressions\nstate    – state variable\ninput    – input variable\nnoise    – noise variable\n\nOutput\n\nArray of tuples of symbols with variable name and field name.\n\nExample\n\njulia> using MathematicalSystems: extract_sum\n\njulia> extract_sum([:(A1*x)], :x, :u, :w)\n1-element Array{Tuple{Any,Symbol},1}:\n (:(hcat(A1)), :A)\n\njulia> extract_sum([:(A1*x), :(B1*u), :c], :x, :u, :w)\n3-element Array{Tuple{Any,Symbol},1}:\n (:(hcat(A1)), :A)\n (:(hcat(B1)), :B)\n (:(vcat(c)), :c)\n\njulia> extract_sum([:(A1*x7), :( B1*u7), :( B2*w7)], :x7, :u7, :w7)\n3-element Array{Tuple{Any,Symbol},1}:\n (:(hcat(A1)), :A)\n (:(hcat(B1)), :B)\n (:(hcat(B2)), :D)\n\nNotes\n\nIf an element of summands is a multiplication expression lhs*rhs, return lhs as variable name and :A as field name if rhs==state, :B as field name if rhs==input and :D as field name if rhs==noise.\n\nIf an element of summands is a symbol, and not equal to input or noise, the symbol is the variable name and the field name is :c. If it is equal to input, the variable name is a IdentityMultiple(I,state_dim) where state_dim is extracted from the state matrix (i.e. take the symbol lhs of lhs*rhs where rhs==state which corresponds to the state matrix and generate the expression state_dim = size(lhs,1) which is evaluated in the scope where @system is called) and the field name is :B.\n\nSimiliarily, if the element is equal to noise, the variable name is IdentityMultiple(I, state_dim) and the field name is :D.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#Naming-convention-for-systems'-fields-1","page":"Internals","title":"Naming convention for systems' fields","text":"","category":"section"},{"location":"lib/internals/#","page":"Internals","title":"Internals","text":"Systems' fields should be accessed externally by their respective getter functions. Internally to the library, the following naming conventions are used.","category":"page"},{"location":"lib/internals/#","page":"Internals","title":"Internals","text":"Field Description Getter function\nA state matrix state_matrix\nB input matrix input_matrix\nc affine term affine_term\nD noise matrix noise_matrix\nX state constraints stateset\nU input constraints inputset\nW disturbance set noiseset","category":"page"},{"location":"about/#About-1","page":"About","title":"About","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Pages = [\"about.md\"]","category":"page"},{"location":"about/#Contributing-1","page":"About","title":"Contributing","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"If you like this package, consider contributing! You can send bug reports (or fix them and send your code), add examples to the documentation, or propose new features.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Below some conventions that we follow when contributing to this package are detailed. For specific guidelines on documentation, see the Documentations Guidelines wiki.","category":"page"},{"location":"about/#Branches-and-pull-requests-(PR)-1","page":"About","title":"Branches and pull requests (PR)","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"We use a standard pull request policy: You work in a private branch and eventually add a pull request, which is then reviewed by other programmers and merged into the master branch.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Each pull request should be pushed in a new branch with the name of the author followed by a descriptive name, e.g., mforets/my_feature. If the branch is associated to a previous discussion in one issue, we use the name of the issue for easier lookup, e.g., mforets/7.","category":"page"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)-1","page":"About","title":"Unit testing and continuous integration (CI)","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This project is synchronized with Travis CI such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to understand and fix the failing doctests if they exist. We develop in Julia v0.6.0, but for experimentation we also build on the nightly branch.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"When you modify code in this package, you should make sure that all unit tests pass. To run the unit tests locally, you should do:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes test/runtests.jl","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Alternatively, you can achieve the same from inside the REPL using the following command:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"julia> Pkg.test(\"MathematicalSystems\")","category":"page"},{"location":"about/#","page":"About","title":"About","text":"We also advise adding new unit tests when adding new features to ensure long-term support of your contributions.","category":"page"},{"location":"about/#Contributing-to-the-documentation-1","page":"About","title":"Contributing to the documentation","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"New functions and types should be documented according to our guidelines directly in the source code.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"You can view the source code documentation from inside the REPL by typing ? followed by the name of the type or function. For example, the following command will print the documentation of the AbstractSystem type:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"julia> ?LinearContinuousSystem","category":"page"},{"location":"about/#","page":"About","title":"About","text":"This documentation you are currently reading is written in Markdown, and it relies on Documenter.jl to produce the HTML layout. The sources for creating this documentation are found in docs/src. You can easily include the documentation that you wrote for your functions or types there (see the Documenter.jl guide or our sources for examples).","category":"page"},{"location":"about/#","page":"About","title":"About","text":"To generate the documentation locally, run make.jl, e.g., by executing the following command in the terminal:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Note that this also runs all doctests which will take some time.","category":"page"},{"location":"about/#Related-projects-1","page":"About","title":"Related projects","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This package originated from Hybrid Systems and systems definitions for reachability problems within JuliaReach.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Below we list more related projects.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Package name Description\nHybridSystems.jl Hybrid Systems definitions in Julia.\nLTISystems.jl Julia package for representing linear time-invariant system models and operations defined on them.\nControlToolbox.jl Analysis and design tools for control systems.\nronisbr/ControlToolbox.jl A Control Toolbox for Julia language.\nDynamicalSystemsBase.jl Definitions of core system and data types used in the ecosystem of DynamicalSystems.jl.\nControlSystems.jl A Control Systems Toolbox for Julia\nModelingToolkit.jl A toolkit for modeling and creating DSLs for Scientific Computing in Julia","category":"page"},{"location":"about/#Credits-1","page":"About","title":"Credits","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"These persons have contributed to MathematicalSystems.jl (in alphabetic order):","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Marcelo Forets\nBenoît Legat\nChristian Schilling\nUeli Wechsler","category":"page"},{"location":"lib/types/#Types-1","page":"Types","title":"Types","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"This section describes systems types implemented in MathematicalSystems.jl.","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"Pages = [\"types.md\"]\nDepth = 3","category":"page"},{"location":"lib/types/#","page":"Types","title":"Types","text":"CurrentModule = MathematicalSystems\nDocTestSetup = quote\n    using MathematicalSystems\nend","category":"page"},{"location":"lib/types/#Abstract-Systems-1","page":"Types","title":"Abstract Systems","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"AbstractSystem\nAbstractContinuousSystem\nAbstractDiscreteSystem","category":"page"},{"location":"lib/types/#MathematicalSystems.AbstractSystem","page":"Types","title":"MathematicalSystems.AbstractSystem","text":"AbstractSystem\n\nAbstract supertype for all system types.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.AbstractContinuousSystem","page":"Types","title":"MathematicalSystems.AbstractContinuousSystem","text":"AbstractContinuousSystem\n\nAbstract supertype for all continuous system types.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.AbstractDiscreteSystem","page":"Types","title":"MathematicalSystems.AbstractDiscreteSystem","text":"AbstractDiscreteSystem\n\nAbstract supertype for all discrete system types.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Continuous-Systems-1","page":"Types","title":"Continuous Systems","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"ContinuousIdentitySystem\nConstrainedContinuousIdentitySystem\nLinearContinuousSystem\nAffineContinuousSystem\nLinearControlContinuousSystem\nConstrainedLinearContinuousSystem\nConstrainedAffineContinuousSystem\nConstrainedAffineControlContinuousSystem\nConstrainedLinearControlContinuousSystem\nLinearAlgebraicContinuousSystem\nConstrainedLinearAlgebraicContinuousSystem\nPolynomialContinuousSystem\nConstrainedPolynomialContinuousSystem\nBlackBoxContinuousSystem\nConstrainedBlackBoxContinuousSystem\nBlackBoxControlContinuousSystem\nConstrainedBlackBoxControlContinuousSystem\nNoisyLinearContinuousSystem\nNoisyConstrainedLinearContinuousSystem\nNoisyLinearControlContinuousSystem\nNoisyConstrainedLinearControlContinuousSystem\nNoisyAffineControlContinuousSystem\nNoisyConstrainedAffineControlContinuousSystem\nNoisyBlackBoxControlContinuousSystem\nNoisyConstrainedBlackBoxControlContinuousSystem","category":"page"},{"location":"lib/types/#MathematicalSystems.ContinuousIdentitySystem","page":"Types","title":"MathematicalSystems.ContinuousIdentitySystem","text":"ContinuousIdentitySystem <: AbstractContinuousSystem\n\nTrivial identity continuous-time system of the form:\n\n    x(t) = 0  forall t\n\nFields\n\nstatedim – number of state variables\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedContinuousIdentitySystem","page":"Types","title":"MathematicalSystems.ConstrainedContinuousIdentitySystem","text":"ConstrainedContinuousIdentitySystem <: AbstractContinuousSystem\n\nTrivial identity continuous-time system with domain constraints of the form:\n\n    x(t) = 0  x(t)  mathcalX  forall t\n\nFields\n\nstatedim – number of state variables\nX        – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.LinearContinuousSystem","page":"Types","title":"MathematicalSystems.LinearContinuousSystem","text":"LinearContinuousSystem\n\nContinuous-time linear system of the form:\n\n    x(t) = A x(t)  forall t\n\nFields\n\nA – state matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.AffineContinuousSystem","page":"Types","title":"MathematicalSystems.AffineContinuousSystem","text":"AffineContinuousSystem\n\nContinuous-time affine system of the form:\n\n    x(t) = A x(t) + c  forall t\n\nFields\n\nA – state matrix\nc – affine term\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.LinearControlContinuousSystem","page":"Types","title":"MathematicalSystems.LinearControlContinuousSystem","text":"LinearControlContinuousSystem\n\nContinuous-time linear control system of the form:\n\n    x(t) = A x(t) + B u(t)  forall t\n\nFields\n\nA – state matrix\nB – input matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedLinearContinuousSystem","page":"Types","title":"MathematicalSystems.ConstrainedLinearContinuousSystem","text":"ConstrainedLinearContinuousSystem\n\nContinuous-time linear system with domain constraints of the form:\n\n    x(t) = A x(t)  x(t)  mathcalX  forall t\n\nFields\n\nA – state matrix\nX – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedAffineContinuousSystem","page":"Types","title":"MathematicalSystems.ConstrainedAffineContinuousSystem","text":"ConstrainedAffineContinuousSystem\n\nContinuous-time affine system with domain constraints of the form:\n\n    x(t) = A x(t) + c  x(t)  mathcalX  forall t\n\nFields\n\nA – state matrix\nc – affine term\nX – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedAffineControlContinuousSystem","page":"Types","title":"MathematicalSystems.ConstrainedAffineControlContinuousSystem","text":"ConstrainedAffineControlContinuousSystem\n\nContinuous-time affine control system with domain constraints of the form:\n\n    x(t) = A x(t) + B u(t) + c  x(t)  mathcalX  u(t)  mathcalU  forall t\n\nFields\n\nA – state matrix\nB – input matrix\nc – affine term\nX – state constraints\nU – input constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedLinearControlContinuousSystem","page":"Types","title":"MathematicalSystems.ConstrainedLinearControlContinuousSystem","text":"ConstrainedLinearControlContinuousSystem\n\nContinuous-time linear control system with domain constraints of the form:\n\n    x(t) = A x(t) + B u(t)  x(t)  mathcalX  u(t)  mathcalU  forall t\n\nFields\n\nA – state matrix\nB – input matrix\nX – state constraints\nU – input constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.LinearAlgebraicContinuousSystem","page":"Types","title":"MathematicalSystems.LinearAlgebraicContinuousSystem","text":"LinearAlgebraicContinuousSystem\n\nContinuous-time linear algebraic system of the form:\n\n    E x(t) = A x(t)  forall t\n\nFields\n\nA – state matrix\nE – matrix, same size as A\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedLinearAlgebraicContinuousSystem","page":"Types","title":"MathematicalSystems.ConstrainedLinearAlgebraicContinuousSystem","text":"ConstrainedLinearAlgebraicContinuousSystem\n\nContinuous-time linear system with domain constraints of the form:\n\n    E x(t) = A x(t)  x(t)  mathcalX  forall t\n\nFields\n\nA – state matrix\nE – matrix, same size as A\nX – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.PolynomialContinuousSystem","page":"Types","title":"MathematicalSystems.PolynomialContinuousSystem","text":"PolynomialContinuousSystem\n\nContinuous-time polynomial system of the form:\n\n    x(t) = p(x(t))  forall t\n\nFields\n\np        – polynomial vector field\nstatedim – number of state variables\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedPolynomialContinuousSystem","page":"Types","title":"MathematicalSystems.ConstrainedPolynomialContinuousSystem","text":"ConstrainedPolynomialContinuousSystem\n\nContinuous-time polynomial system with domain constraints:\n\n    x(t) = p(x(t))  x(t)  mathcalX  forall t\n\nFields\n\np        – polynomial vector field\nX        – constraint set\nstatedim – number of state variables\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.BlackBoxContinuousSystem","page":"Types","title":"MathematicalSystems.BlackBoxContinuousSystem","text":"BlackBoxContinuousSystem <: AbstractContinuousSystem\n\nContinuous-time system defined by a right-hand side of the form:\n\n    x(t) = f(x(t))  forall t\n\nFields\n\nf        – function that holds the right-hand side\nstatedim – number of state variables\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedBlackBoxContinuousSystem","page":"Types","title":"MathematicalSystems.ConstrainedBlackBoxContinuousSystem","text":"ConstrainedBlackBoxContinuousSystem <: AbstractContinuousSystem\n\nContinuous-time system defined by a right-hand side with domain constraints of the form:\n\n    x(t) = f(x(t))  x(t)  mathcalX  forall t\n\nFields\n\nf        – function that holds the right-hand side\nstatedim – number of state variables\nX        – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.BlackBoxControlContinuousSystem","page":"Types","title":"MathematicalSystems.BlackBoxControlContinuousSystem","text":"BlackBoxControlContinuousSystem <: AbstractContinuousSystem\n\nContinuous-time control system defined by a right-hand side of the form:\n\n    x(t) = f(x(t) u(t))  forall t\n\nFields\n\nf        – function that holds the right-hand side\nstatedim – number of state variables\ninputdim – number of input variables\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedBlackBoxControlContinuousSystem","page":"Types","title":"MathematicalSystems.ConstrainedBlackBoxControlContinuousSystem","text":"ConstrainedBlackBoxControlContinuousSystem <: AbstractContinuousSystem\n\nContinuous-time control system defined by a right-hand side with domain constraints of the form:\n\n    x(t) = f(x(t) u(t))  x(t)  mathcalX  u(t)  mathcalU  forall t\n\nFields\n\nf        – function that holds the right-hand side\nstatedim – number of state variables\ninputdim – number of input variables\nX        – state constraints\nU        – input constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyLinearContinuousSystem","page":"Types","title":"MathematicalSystems.NoisyLinearContinuousSystem","text":"NoisyLinearContinuousSystem\n\nContinuous-time linear system with additive disturbance of the form:\n\n    x(t) = A x(t) + D w(t)  forall t\n\nFields\n\nA – state matrix\nD – noise matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyConstrainedLinearContinuousSystem","page":"Types","title":"MathematicalSystems.NoisyConstrainedLinearContinuousSystem","text":"NoisyConstrainedLinearContinuousSystem\n\nContinuous-time linear system with  additive disturbance and domain constraints of the form:\n\n    x(t) = A x(t) + D w(t)  x(t)  mathcalX  w(t)  mathcalW  forall t\n\nFields\n\nA – state matrix\nD – noise matrix\nX – state constraints\nW – disturbance set\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyLinearControlContinuousSystem","page":"Types","title":"MathematicalSystems.NoisyLinearControlContinuousSystem","text":"NoisyLinearControlContinuousSystem\n\nContinuous-time linear control system with additive disturbance of the form:\n\n    x(t) = A x(t) + B u(t) + D w(t)  forall t\n\nFields\n\nA – state matrix\nB – input matrix\nD – noise matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyConstrainedLinearControlContinuousSystem","page":"Types","title":"MathematicalSystems.NoisyConstrainedLinearControlContinuousSystem","text":"NoisyConstrainedLinearControlContinuousSystem\n\nContinuous-time linear control system with additive disturbance and domain constraints of the form:\n\n    x(t) = A x(t) + B u(t) + D w(t)  x(t)  mathcalX  u(t)  mathcalU  w(t)  mathcalW  forall t\n\nFields\n\nA – state matrix\nB – input matrix\nD – noise matrix\nX – state constraints\nU – input constraints\nW – disturbance set\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyAffineControlContinuousSystem","page":"Types","title":"MathematicalSystems.NoisyAffineControlContinuousSystem","text":"NoisyAffineControlContinuousSystem\n\nContinuous-time affine control system with additive disturbance of the form:\n\n    x(t) = A x(t) + B u(t) + c + D w(t)  forall t\n\nFields\n\nA – state matrix\nB – input matrix\nc – affine term\nD – noise matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyConstrainedAffineControlContinuousSystem","page":"Types","title":"MathematicalSystems.NoisyConstrainedAffineControlContinuousSystem","text":"NoisyConstrainedAffineControlContinuousSystem\n\nContinuous-time affine control system with additive disturbance and domain constraints of the form:\n\n    x(t) = A x(t) + B u(t) + c + D w(t)  x(t)  mathcalX  u(t)  mathcalU  w(t)  mathcalW  forall t\n\nFields\n\nA – state matrix\nB – input matrix\nc – affine term\nD – noise matrix\nX – state constraints\nU – input constraints\nW – disturbance set\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyBlackBoxControlContinuousSystem","page":"Types","title":"MathematicalSystems.NoisyBlackBoxControlContinuousSystem","text":"NoisyBlackBoxControlContinuousSystem <: AbstractContinuousSystem\n\nContinuous-time disturbance-affected control system defined by a right-hand side of the form:\n\n    x(t) = f(x(t) u(t) w(t))  forall t\n\nFields\n\nf        – function that holds the right-hand side\nstatedim – number of state variables\ninputdim – number of input variables\nnoisedim – number of noise variables\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyConstrainedBlackBoxControlContinuousSystem","page":"Types","title":"MathematicalSystems.NoisyConstrainedBlackBoxControlContinuousSystem","text":"NoisyConstrainedBlackBoxControlContinuousSystem <: AbstractContinuousSystem\n\nContinuous-time disturbance-affected control system defined by a right-hand side with domain constraints of the form:\n\n    x(t) = f(x(t) u(t) w(t)) quad x(t)  mathcalX quad u(t)  mathcalU quad w(t)  mathcalW quad forall t\n\nFields\n\nf        – function that holds the right-hand side\nstatedim – number of state variables\ninputdim – number of input variables\nnoisedim – number of noise variables\nX        – state constraints\nU        – input constraints\nW        – disturbance set\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Discrete-Systems-1","page":"Types","title":"Discrete Systems","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"DiscreteIdentitySystem\nConstrainedDiscreteIdentitySystem\nLinearDiscreteSystem\nAffineDiscreteSystem\nLinearControlDiscreteSystem\nConstrainedLinearDiscreteSystem\nConstrainedAffineDiscreteSystem\nConstrainedLinearControlDiscreteSystem\nConstrainedAffineControlDiscreteSystem\nLinearAlgebraicDiscreteSystem\nConstrainedLinearAlgebraicDiscreteSystem\nPolynomialDiscreteSystem\nConstrainedPolynomialDiscreteSystem\nBlackBoxDiscreteSystem\nConstrainedBlackBoxDiscreteSystem\nBlackBoxControlDiscreteSystem\nConstrainedBlackBoxControlDiscreteSystem\nNoisyLinearDiscreteSystem\nNoisyConstrainedLinearDiscreteSystem\nNoisyLinearControlDiscreteSystem\nNoisyConstrainedLinearControlDiscreteSystem\nNoisyAffineControlDiscreteSystem\nNoisyConstrainedAffineControlDiscreteSystem\nNoisyBlackBoxControlDiscreteSystem\nNoisyConstrainedBlackBoxControlDiscreteSystem","category":"page"},{"location":"lib/types/#MathematicalSystems.DiscreteIdentitySystem","page":"Types","title":"MathematicalSystems.DiscreteIdentitySystem","text":"DiscreteIdentitySystem <: AbstractDiscreteSystem\n\nTrivial identity discrete-time system of the form:\n\n    x_k+1 = x_k  forall k\n\nFields\n\nstatedim – number of state variables\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedDiscreteIdentitySystem","page":"Types","title":"MathematicalSystems.ConstrainedDiscreteIdentitySystem","text":"ConstrainedDiscreteIdentitySystem <: AbstractDiscreteSystem\n\nTrivial identity discrete-time system with domain constraints of the form:\n\n    x_k+1 = x_k  x_k  mathcalX  forall k\n\nFields\n\nstatedim – number of state variables\nX        – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.LinearDiscreteSystem","page":"Types","title":"MathematicalSystems.LinearDiscreteSystem","text":"LinearDiscreteSystem\n\nDiscrete-time linear system of the form:\n\n    x_k+1 = A x_k  forall k\n\nFields\n\nA – state matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.AffineDiscreteSystem","page":"Types","title":"MathematicalSystems.AffineDiscreteSystem","text":"AffineDiscreteSystem\n\nDiscrete-time affine system of the form:\n\n    x_k+1 = A x_k + c  forall k\n\nFields\n\nA – state matrix\nc – affine term\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.LinearControlDiscreteSystem","page":"Types","title":"MathematicalSystems.LinearControlDiscreteSystem","text":"LinearControlDiscreteSystem\n\nDiscrete-time linear control system of the form:\n\n    x_k+1 = A x_k + B u_k  forall k\n\nFields\n\nA – state matrix\nB – input matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedLinearDiscreteSystem","page":"Types","title":"MathematicalSystems.ConstrainedLinearDiscreteSystem","text":"ConstrainedLinearDiscreteSystem\n\nDiscrete-time linear system with domain constraints of the form:\n\n    x_k+1 = A x_k  x_k  mathcalX  forall k\n\nFields\n\nA – state matrix\nX – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedAffineDiscreteSystem","page":"Types","title":"MathematicalSystems.ConstrainedAffineDiscreteSystem","text":"ConstrainedAffineDiscreteSystem\n\nDiscrete-time affine system with domain constraints of the form:\n\n    x_k+1 = A x_k + c  x_k  mathcalX  forall k\n\nFields\n\nA – state matrix\nc – affine term\nX – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedLinearControlDiscreteSystem","page":"Types","title":"MathematicalSystems.ConstrainedLinearControlDiscreteSystem","text":"ConstrainedLinearControlDiscreteSystem\n\nDiscrete-time linear control system with domain constraints of the form:\n\n    x_k+1 = A x_k + B u_k  x_k  mathcalX  u_k  mathcalU  forall k\n\nFields\n\nA – state matrix\nB – input matrix\nX – state constraints\nU – input constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedAffineControlDiscreteSystem","page":"Types","title":"MathematicalSystems.ConstrainedAffineControlDiscreteSystem","text":"ConstrainedAffineControlDiscreteSystem\n\nContinuous-time affine control system with domain constraints of the form:\n\n    x_k+1 = A x_k + B u_k + c  x_k  mathcalX  u_k  mathcalU  forall k\n\nFields\n\nA – state matrix\nB – input matrix\nc – affine term\nX – state constraints\nU – input constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.LinearAlgebraicDiscreteSystem","page":"Types","title":"MathematicalSystems.LinearAlgebraicDiscreteSystem","text":"LinearAlgebraicDiscreteSystem\n\nDiscrete-time linear algebraic system of the form:\n\n    E x_k+1 = A x_k  forall k\n\nFields\n\nA – state matrix\nE – matrix, same size as A\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedLinearAlgebraicDiscreteSystem","page":"Types","title":"MathematicalSystems.ConstrainedLinearAlgebraicDiscreteSystem","text":"ConstrainedLinearAlgebraicDiscreteSystem\n\nDiscrete-time linear system with domain constraints of the form:\n\n    E x_k+1 = A x_k  x_k  mathcalX  forall k\n\nFields\n\nA – state matrix\nE – matrix, same size as A\nX – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.PolynomialDiscreteSystem","page":"Types","title":"MathematicalSystems.PolynomialDiscreteSystem","text":"PolynomialDiscreteSystem\n\nDiscrete-time polynomial system of the form:\n\n    x_k+1 = p(x_k)  forall k\n\nFields\n\np        – polynomial vector field\nstatedim – number of state variables\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedPolynomialDiscreteSystem","page":"Types","title":"MathematicalSystems.ConstrainedPolynomialDiscreteSystem","text":"ConstrainedPolynomialDiscreteSystem\n\nDiscrete-time polynomial system with domain constraints:\n\n    x_k+1 = p(x_k)   x_k  mathcalX  forall k\n\nFields\n\np        – polynomial\nX        – constraint set\nstatedim – number of state variables\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.BlackBoxDiscreteSystem","page":"Types","title":"MathematicalSystems.BlackBoxDiscreteSystem","text":"BlackBoxDiscreteSystem <: AbstractDiscreteSystem\n\nDiscrete-time system defined by a right-hand side of the form:\n\n    x_k+1 = f(x_k)  forall k\n\nFields\n\nf        – function that holds the right-hand side\nstatedim – number of state variables\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedBlackBoxDiscreteSystem","page":"Types","title":"MathematicalSystems.ConstrainedBlackBoxDiscreteSystem","text":"ConstrainedBlackBoxDiscreteSystem <: AbstractDiscreteSystem\n\nDiscrete-time system defined by a right-hand side with domain constraints of the form:\n\n    x_k+1 = f(x_k)  x_k  mathcalX  forall k\n\nFields\n\nf        – function that holds the right-hand side\nstatedim – number of state variables\nX        – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.BlackBoxControlDiscreteSystem","page":"Types","title":"MathematicalSystems.BlackBoxControlDiscreteSystem","text":"BlackBoxControlDiscreteSystem <: AbstractDiscreteSystem\n\nDiscrete-time control system defined by a right-hand side of the form:\n\n    x_k+1 = f(x_k u_k)  forall k\n\nFields\n\nf        – function that holds the right-hand side\nstatedim – number of state variables\ninputdim – number of input variables\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedBlackBoxControlDiscreteSystem","page":"Types","title":"MathematicalSystems.ConstrainedBlackBoxControlDiscreteSystem","text":"ConstrainedBlackBoxControlDiscreteSystem <: AbstractDiscreteSystem\n\nDiscrete-time control system defined by a right-hand side with domain constraints of the form:\n\n    x_k+1 = f(x_k u_k)  x_k  mathcalX   u_k  mathcalU  forall k\n\nFields\n\nf        – function that holds the right-hand side\nstatedim – number of state variables\ninputdim – number of input variables\nX        – state constraints\nU        – input constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyLinearDiscreteSystem","page":"Types","title":"MathematicalSystems.NoisyLinearDiscreteSystem","text":"NoisyLinearDiscreteSystem\n\nDiscrete-time linear system with additive disturbance of the form:\n\n    x_k+1 = A x_k + D w_k  forall k\n\nFields\n\nA – state matrix\nD – noise matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyConstrainedLinearDiscreteSystem","page":"Types","title":"MathematicalSystems.NoisyConstrainedLinearDiscreteSystem","text":"NoisyConstrainedLinearDiscreteSystem\n\nDiscrete-time linear system with additive disturbance and domain constraints of the form:\n\n    x_k+1 = A x_k + D w_k  x_k  mathcalX  w(t)  mathcalW  forall k\n\nFields\n\nA – state matrix\nD – noise matrix\nX – state constraints\nW – disturbance set\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyLinearControlDiscreteSystem","page":"Types","title":"MathematicalSystems.NoisyLinearControlDiscreteSystem","text":"NoisyLinearControlDiscreteSystem\n\nContinuous-time linear control system with additive disturbance of the form:\n\n    x_k+1 = A x_k + B u_k + D w_k  forall k\n\nFields\n\nA – state matrix\nB – input matrix\nD – noise matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyConstrainedLinearControlDiscreteSystem","page":"Types","title":"MathematicalSystems.NoisyConstrainedLinearControlDiscreteSystem","text":"NoisyConstrainedLinearControlDiscreteSystem\n\nContinuous-time linear control system with additive disturbance and domain constraints of the form:\n\n    x_k+1 = A x_k + B u_k + D w_k  x_k  mathcalX  u_k  mathcalU  w_k  mathcalW  forall k\n\nFields\n\nA – state matrix\nB – input matrix\nD – noise matrix\nX – state constraints\nU – input constraints\nW – disturbance set\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyAffineControlDiscreteSystem","page":"Types","title":"MathematicalSystems.NoisyAffineControlDiscreteSystem","text":"NoisyAffineControlDiscreteSystem\n\nContinuous-time affine control system with additive disturbance of the form:\n\n    x_k+1 = A x_k + B u_k + c + D w_k  forall k\n\nFields\n\nA – state matrix\nB – input matrix\nc – affine term\nD – noise matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyConstrainedAffineControlDiscreteSystem","page":"Types","title":"MathematicalSystems.NoisyConstrainedAffineControlDiscreteSystem","text":"NoisyConstrainedAffineControlDiscreteSystem\n\nContinuous-time affine control system with additive disturbance and domain constraints of the form:\n\n    x_k+1 = A x_k + B u_k + c + D w_k  x_k  mathcalX  u_k  mathcalU  w_k  mathcalW  forall k\n\nFields\n\nA – state matrix\nB – input matrix\nc – affine term\nD – noise matrix\nX – state constraints\nU – input constraints\nW – disturbance set\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyBlackBoxControlDiscreteSystem","page":"Types","title":"MathematicalSystems.NoisyBlackBoxControlDiscreteSystem","text":"NoisyBlackBoxControlDiscreteSystem <: AbstractDiscreteSystem\n\nDiscrete-time disturbance-affected control system defined by a right-hand side of the form:\n\n    x_k+1 = f(x_k u_k) quad forall k\n\nFields\n\nf        – function that holds the right-hand side\nstatedim – number of state variables\ninputdim – number of input variables\nnoisedim – number of noise variables\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.NoisyConstrainedBlackBoxControlDiscreteSystem","page":"Types","title":"MathematicalSystems.NoisyConstrainedBlackBoxControlDiscreteSystem","text":"NoisyConstrainedBlackBoxControlDiscreteSystem <: AbstractDiscreteSystem\n\nDiscrete-time disturbance-affected control system defined by a right-hand side with domain constraints of the form:\n\n    x_k+1 = f(x_k u_k) quad x_k  mathcalX quad u_k  mathcalU quad w_k  mathcalW quad forall k\n\nFields\n\nf        – function that holds the right-hand side\nstatedim – number of state variables\ninputdim – number of input variables\nnoisedim – number of noise variables\nX        – state constraints\nU        – input constraints\nW        – disturbance set\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Discretization-Algorithms-1","page":"Types","title":"Discretization Algorithms","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"AbstractDiscretizationAlgorithm\nExactDiscretization\nEulerDiscretization","category":"page"},{"location":"lib/types/#MathematicalSystems.AbstractDiscretizationAlgorithm","page":"Types","title":"MathematicalSystems.AbstractDiscretizationAlgorithm","text":"AbstractDiscretizationAlgorithm\n\nAbstract supertype for all discretization algorithms.\n\nNote\n\nFor implementing a custom discretization algorithm, a type definition struct NewDiscretizationAlgorithm <: AbstractDiscretizationAlgorithm end and a _discretize method\n\n_discretize(::NewDiscretizationAlgorithm, ΔT::Real,\n             A::AbstractMatrix, B::AbstractMatrix, c::AbstractVector, D::AbstractMatrix)\n\nare required.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ExactDiscretization","page":"Types","title":"MathematicalSystems.ExactDiscretization","text":"ExactDiscretization <: AbstractDiscretizationAlgorithm\n\nExact discretization algorithm for affine systems.\n\nAlgorithm\n\nThis algorithm consists of integrating the continuous differential equation over a specified time interval to obtain an associated difference equation. The algorithm applies to any system of the form x' = Ax + Bu + c + Dw where the state matrix A is invertible, and other system types, e.g. linear systems x' = Ax which are included in the above formulation.\n\nWithout loss of generality, consider a NoisyAffineControlledContinuousSystem with system dynamics x = Ax + Bu + c + Dw.\n\nThe exact discretization is calculated by integrating on both sides of the continuous ODE over the time span [t, t + ΔT], for a fixed input u and fixed noise realization w at time t. The resulting discretization writes as x^+ = A^d x + B^d u + c^d  + D^d w where A^d = exp^A  ΔT, B^d = A^-1(A^d - I)B, c^d = A^-1(A^d - I)c and D^d = A^-1(A^d - I)D.\n\nThe algorithm described above is a well known result from the literature [1].\n\n[1] https://en.wikipedia.org/wiki/Discretization#Discretizationoflinearstatespace_models\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.EulerDiscretization","page":"Types","title":"MathematicalSystems.EulerDiscretization","text":"EulerDiscretization <: AbstractDiscretizationAlgorithm\n\nEuler discretization algorithm for affine systems.\n\nAlgorithm\n\nThis algorithm consists of a first-order approximation to obtain an associated difference equation. The algorithm applies to any system of the form x' = Ax + Bu + c + Dw, and other system types, e.g. linear systems x' = Ax which are included in the above formulation.\n\nWithout loss of generality, consider a NoisyAffineControlledContinuousSystem with system dynamics x = Ax + Bu + c + Dw.\n\nThe Euler discretization is calculated by taking the first-order approximation of the exact discretization ExactDiscretization. The resulting discretization writes as x^+ = A^d x + B^d u + c^d + D^d w where  A^d = I + ΔT  A, B^d = ΔT  B, c^d = ΔT  c and D^d = ΔT  D.\n\nThe algorithm described above is a well known result from the literature [1].\n\n[1] https://en.wikipedia.org/wiki/Discretization#Approximations\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#System-macro-1","page":"Types","title":"System macro","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"@system","category":"page"},{"location":"lib/types/#MathematicalSystems.@system","page":"Types","title":"MathematicalSystems.@system","text":"system(expr...)\n\nReturn an instance of the system type corresponding to the given expressions.\n\nInput\n\nexpr – expressions separated by commas which define the dynamic equation,           the constraint sets or the dimensionality of the system\n\nOutput\n\nA system that best matches the given expressions.\n\nNotes\n\nTerms. The expression expr contains one or more of the following sub-expressions:\n\ndynamic equation, either continuous, e.g.x' = Ax, or discrete, e.g. x⁺ = Ax\nset constraints, e.g. x ∈ X\ninput constraints, e.g. u ∈ U\ndimensionality, e.g. dim: (2,1) or dim = 1\nspecification of the input variable, e.g. input: u or input = u\nspecification of the noise variable, e,g, noise: w or noise = w\n\nThe macro call is then formed by separating the previous sub-expressions (which we simply call terms hereafter), as in:\n\n@system(dynamic eq., set constr., input constr., input specif., noise spec., dimens.)\n\nThe different terms that compose the system's definition do not have to appear in any particular order. Moreover, the only mandatory term is the dynamic equation; the other terms are optional and default values may apply depending on the system type; this is explained next.\n\nDynamic equation. The time derivative in a continuous system is specified by using ', as in x' = A*x. A discrete system is specified using ⁺ (which can be written with the combination of keys \\^+[TAB]), as in x⁺ = A*x. Moreover, the asterisk denoting matrix-vector products is optional. For instance, both x' = Ax and x' = A*x are parsed as the linear continuous system whose state matrix is A. The matrix is supposed to be defined at the call site.\n\nDefault values. When the dynamic equation is parsed, the variable on the left-hand side is interpreted as the state variable. The input variable is by default u and the noise variable is by default w. If we want to change the default name of the input variable, this can be done by adding the term input: var (or equivalently, input=var) where var corresponds to the new name of the input variable, eg. @system(x' = A*x + B*v, input:v). Similarly, a noise variable is specified with noise: var or noise=var.\n\nExceptions. The following exceptions and particular cases apply:\n\nIf the right-hand side has the form A*x + B*foo, A*x + B*foo + c or f(x, foo), the equation is parsed as a controlled linear (affine) or controlled black-box system with input foo. Note that in this case, input variable does not correspond to the default value of u, but foo is parsed as being the input.\nIf the left-hand side contains a multiplicative term in the form E*x⁺ or E*x', the equation is parsed as an algebraic system. In this case, the asterisk * operator is mandatory.\nSystems of the form x' = α*x where α is a scalar are parsed as linear systems. The default dimension is 1 and α is parsed as Float64; if the system is higher-dimensional, use dim, as in x' = 2x, dim=3.\n\nExamples\n\nLet us first create a continuous linear system using this macro:\n\njulia> A = [1. 0; 0 1.];\n\njulia> @system(x' = A*x)\nLinearContinuousSystem{Float64,Array{Float64,2}}([1.0 0.0; 0.0 1.0])\n\nA discrete system is defined by using ⁺:\n\njulia> @system(x⁺ = A*x)\nLinearDiscreteSystem{Float64,Array{Float64,2}}([1.0 0.0; 0.0 1.0])\n\nAdditionally, a set definition x ∈ X can be added to create a constrained system. For example, a discrete controlled affine system with constrained states and inputs writes as:\n\njulia> using LazySets\n\njulia> B = Matrix([1. 0.5]');\n\njulia> c = [1., 1.5];\n\njulia> X = BallInf(zeros(2), 10.);\n\njulia> U = BallInf(zeros(1), 2.);\n\njulia> @system(x' = A*x + B*u + c, x ∈ X, u ∈ U)\nConstrainedAffineControlContinuousSystem{Float64,Array{Float64,2},Array{Float64,2},Array{Float64,1},BallInf{Float64,Array{Float64,1}},BallInf{Float64,Array{Float64,1}}}([1.0 0.0; 0.0 1.0], [1.0; 0.5], [1.0, 1.5], BallInf{Float64,Array{Float64,1}}([0.0, 0.0], 10.0), BallInf{Float64,Array{Float64,1}}([0.0], 2.0))\n\nFor the creation of a black-box system, the state, input and noise dimensions have to be defined separately. For a constrained controlled black-box system, the macro writes as\n\njulia> f(x, u) = x + u;\n\njulia> @system(x⁺ = f(x, u), x ∈ X, u ∈ U, dim: (2,2))\nConstrainedBlackBoxControlDiscreteSystem{typeof(f),BallInf{Float64,Array{Float64,1}},BallInf{Float64,Array{Float64,1}}}(f, 2, 2, BallInf{Float64,Array{Float64,1}}([0.0, 0.0], 10.0), BallInf{Float64,Array{Float64,1}}([0.0], 2.0))\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#Initial-value-problem-macro-1","page":"Types","title":"Initial-value problem macro","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"@ivp","category":"page"},{"location":"lib/types/#MathematicalSystems.@ivp","page":"Types","title":"MathematicalSystems.@ivp","text":"ivp(expr...)\n\nReturn an instance of the initial-value problem type corresponding to the given expressions.\n\nInput\n\nexpr – expressions separated by commas which define the dynamic equation,           the constraint sets or the dimensionality of the system, and the set           of initial states (required)\n\nOutput\n\nAn initial-value problem that best matches the given expressions.\n\nNotes\n\nThis macro behaves like the @system macro, the sole difference being that in @ivp the constraint on the set of initial states is mandatory. For the technical details we refer to the documentation of @system.\n\nThe macro can also be called with a system argument of type AbstractSystem in the form @ivp(system, state(0) ∈ initial_set).\n\nExamples\n\njulia> p = @ivp(x' = -x, x(0) ∈ [1.0]);\n\njulia> typeof(p)\nInitialValueProblem{LinearContinuousSystem{Float64,IdentityMultiple{Float64}},Array{Float64,1}}\n\njulia> initial_state(p)\n1-element Array{Float64,1}:\n 1.0\n\njulia> sys = @system(x' = [1 0; 0 1] * x);\n\njulia> @ivp(sys, x(0) ∈ [-1, 1])\nInitialValueProblem{LinearContinuousSystem{Int64,Array{Int64,2}},Array{Int64,1}}(LinearContinuousSystem{Int64,Array{Int64,2}}([1 0; 0 1]), [-1, 1])\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#Identity-operator-1","page":"Types","title":"Identity operator","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"IdentityMultiple","category":"page"},{"location":"lib/types/#MathematicalSystems.IdentityMultiple","page":"Types","title":"MathematicalSystems.IdentityMultiple","text":"IdentityMultiple{T} < AbstractMatrix{T} where T\n\nA scalar multiple of the identity matrix of given order and numeric type.\n\nFields\n\nM – uniform scaling operator of type T\nn – size of the identity matrix\n\nNotes\n\nThis type can be used to create multiples of the identity of given size. Since only the multiple and the order are stored, the allocations are minimal.\n\nInternally, the type wraps Julia's lazy multiple of the identity operator, UniformScaling. IdentityMultiple subtypes AbstractMatix, hence it can be used in usual matrix arithmetic and for dispatch on AbstractMatrix.\n\nThe difference between UniformScaling and IdentityMultiple is that while the size of the former is generic, the size of the latter is fixed.\n\nExamples\n\nThe easiest way to create an identity multiple is to use the callable version of LinearAlgebra.I:\n\njulia> using MathematicalSystems: IdentityMultiple\n\njulia> I2 = I(2)\nIdentityMultiple{Float64} of value 1.0 and order 2\n\njulia> I2 + I2\nIdentityMultiple{Float64} of value 2.0 and order 2\n\njulia> 4*I2\nIdentityMultiple{Float64} of value 4.0 and order 2\n\nThe numeric type (default Float64) can be passed as a second argument:\n\njulia> I2r = I(2, Rational{Int})\nIdentityMultiple{Rational{Int64}} of value 1//1 and order 2\n\njulia> I2r + I2r\nIdentityMultiple{Rational{Int64}} of value 2//1 and order 2\n\njulia> 4*I2r\nIdentityMultiple{Rational{Int64}} of value 4//1 and order 2\n\nTo create the matrix with a value different from the default (1.0), there are two ways. Either pass the value through the callable I, as in:\n\njulia> I2 = I(2.0, 2)\nIdentityMultiple{Float64} of value 2.0 and order 2\n\njulia> I2r = I(2//1, 2)\nIdentityMultiple{Rational{Int64}} of value 2//1 and order 2\n\nOr use the constructor passing the UniformScaling (I):\n\njulia> I2 = IdentityMultiple(2.0*I, 2)\nIdentityMultiple{Float64} of value 2.0 and order 2\n\njulia> I2r = IdentityMultiple(2//1*I, 2)\nIdentityMultiple{Rational{Int64}} of value 2//1 and order 2\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Initial-Value-Problems-1","page":"Types","title":"Initial Value Problems","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"InitialValueProblem\nIVP\ninitial_state\nsystem","category":"page"},{"location":"lib/types/#MathematicalSystems.InitialValueProblem","page":"Types","title":"MathematicalSystems.InitialValueProblem","text":"InitialValueProblem{S <: AbstractSystem, XT} <: AbstractSystem\n\nParametric composite type for initial value problems. It is parameterized in the system's type and the initial state's type\n\nFields\n\ns  – system\nx0 – initial state\n\nExamples\n\nThe linear system x = -x with initial condition x₀ = -12 12:\n\njulia> s = LinearContinuousSystem([-1.0 0.0; 0.0 -1.0]);\n\njulia> x₀ = [-1/2, 1/2];\n\njulia> p = InitialValueProblem(s, x₀);\n\njulia> initial_state(p) # same as p.x0\n2-element Array{Float64,1}:\n -0.5\n  0.5\n\njulia> statedim(p)\n2\n\njulia> inputdim(p)\n0\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.IVP","page":"Types","title":"MathematicalSystems.IVP","text":"IVP\n\nIVP is an alias for InitialValueProblem.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.initial_state","page":"Types","title":"MathematicalSystems.initial_state","text":"initial_state(ivp::InitialValueProblem)\n\nReturn the initial state of an initial-value problem.\n\nInput\n\nivp – initial-value problem\n\nOutput\n\nThe initial state of an initial-value problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#MathematicalSystems.system","page":"Types","title":"MathematicalSystems.system","text":"system(ivp::InitialValueProblem)\n\nReturn the system wrapped by an initial-value problem.\n\nInput\n\nivp – initial-value problem\n\nOutput\n\nThe system of the given initial-value problem.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#Input-Types-1","page":"Types","title":"Input Types","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"AbstractInput\nConstantInput\nVaryingInput","category":"page"},{"location":"lib/types/#MathematicalSystems.AbstractInput","page":"Types","title":"MathematicalSystems.AbstractInput","text":"AbstractInput\n\nAbstract supertype for all input types.\n\nNotes\n\nThe input types defined here implement an iterator interface, such that other methods can build upon the behavior of inputs which are either constant or varying.\n\nIteration is supported with an index number called iterator state. The iteration function Base.iterate takes and returns a tuple (input, state), where input represents the value of the input, and state is an index which counts the number of times this iterator was called.\n\nA convenience function nextinput(input, n) is also provided and it returns the first n elements of input.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstantInput","page":"Types","title":"MathematicalSystems.ConstantInput","text":"ConstantInput{UT} <: AbstractInput\n\nType representing an input that remains constant in time.\n\nFields\n\nU – input set\n\nExamples\n\nThe constant input holds a single element and its length is infinite. To access the field U, you can use Base's iterate given a state, or the method  nextinput given the number of desired input elements:\n\njulia> c = ConstantInput(-1//2)\nConstantInput{Rational{Int64}}(-1//2)\n\njulia> iterate(c, 1)\n(-1//2, nothing)\n\njulia> iterate(c, 2)\n(-1//2, nothing)\n\njulia> collect(nextinput(c, 4))\n4-element Array{Rational{Int64},1}:\n -1//2\n -1//2\n -1//2\n -1//2\n\nThe elements of this input are rational numbers:\n\njulia> eltype(c)\nRational{Int64}\n\nTo transform a constant input, you can use map as in:\n\njulia> map(x->2*x, c)\nConstantInput{Rational{Int64}}(-1//1)\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.VaryingInput","page":"Types","title":"MathematicalSystems.VaryingInput","text":"VaryingInput{UT, VUT<:AbstractVector{UT}} <: AbstractInput\n\nType representing an input that may vary with time.\n\nFields\n\nU – vector of input sets\n\nExamples\n\nThe varying input holds a vector and its length equals the number of elements in the vector. Consider an input given by a vector of rational numbers:\n\njulia> v = VaryingInput([-1//2, 1//2])\nVaryingInput{Rational{Int64},Array{Rational{Int64},1}}(Rational{Int64}[-1//2, 1//2])\n\njulia> length(v)\n2\n\njulia> eltype(v)\nRational{Int64}\n\nBase's iterate method receives the input and an integer state and returns the input element and the next iteration state:\n\njulia> iterate(v, 1)\n(-1//2, 2)\n\njulia> iterate(v, 2)\n(1//2, 3)\n\nThe method nextinput receives a varying input and an integer n and returns an iterator over the first n elements of this input (where n=1 by default):\n\njulia> typeof(nextinput(v))\nBase.Iterators.Take{VaryingInput{Rational{Int64},Array{Rational{Int64},1}}}\n\njulia> collect(nextinput(v, 1))\n1-element Array{Rational{Int64},1}:\n -1//2\n\njulia> collect(nextinput(v, 2))\n2-element Array{Rational{Int64},1}:\n -1//2\n  1//2\n\nYou can collect the inputs in an array, or equivalently use list comprehension, (or use a for loop):\n\njulia> collect(v)\n2-element Array{Rational{Int64},1}:\n -1//2\n  1//2\n\njulia> [2*vi for vi in v]\n2-element Array{Rational{Int64},1}:\n -1//1\n  1//1\n\nSince this input type is finite, querying more elements than its length returns the full vector:\n\njulia> collect(nextinput(v, 4))\n2-element Array{Rational{Int64},1}:\n -1//2\n  1//2\n\nTo transform a varying input, you can use map as in:\n\njulia> map(x->2*x, v)\nVaryingInput{Rational{Int64},Array{Rational{Int64},1}}(Rational{Int64}[-1//1, 1//1])\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Maps-1","page":"Types","title":"Maps","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"AbstractMap\nIdentityMap\nConstrainedIdentityMap\nLinearMap\nConstrainedLinearMap\nAffineMap\nConstrainedAffineMap\nLinearControlMap\nConstrainedLinearControlMap\nAffineControlMap\nConstrainedAffineControlMap\nResetMap\nConstrainedResetMap","category":"page"},{"location":"lib/types/#MathematicalSystems.AbstractMap","page":"Types","title":"MathematicalSystems.AbstractMap","text":"AbstractMap\n\nAbstract supertype for all map types.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.IdentityMap","page":"Types","title":"MathematicalSystems.IdentityMap","text":"IdentityMap\n\nAn identity map,\n\n    x  x\n\nFields\n\ndim – dimension\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedIdentityMap","page":"Types","title":"MathematicalSystems.ConstrainedIdentityMap","text":"ConstrainedIdentityMap\n\nAn identity map with state constraints of the form:\n\n    x  x x(t)  mathcalX\n\nFields\n\ndim – dimension\nX   – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.LinearMap","page":"Types","title":"MathematicalSystems.LinearMap","text":"LinearMap\n\nA linear map,\n\n    x  Ax\n\nFields\n\nA – matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedLinearMap","page":"Types","title":"MathematicalSystems.ConstrainedLinearMap","text":"ConstrainedLinearMap\n\nA linear map with state constraints of the form:\n\n    x  Ax x(t)  mathcalX\n\nFields\n\nA – matrix\nX – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.AffineMap","page":"Types","title":"MathematicalSystems.AffineMap","text":"AffineMap\n\nAn affine map,\n\n    x  Ax + c\n\nFields\n\nA – matrix\nc – vector\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedAffineMap","page":"Types","title":"MathematicalSystems.ConstrainedAffineMap","text":"ConstrainedAffineMap\n\nAn affine map with state constraints of the form:\n\n    x  Ax + c x(t)  mathcalX\n\nFields\n\nA – matrix\nc – vector\nX – state constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.LinearControlMap","page":"Types","title":"MathematicalSystems.LinearControlMap","text":"LinearControlMap\n\nA linear control map,\n\n    (x u)  Ax + Bu\n\nFields\n\nA – matrix\nB – matrix\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedLinearControlMap","page":"Types","title":"MathematicalSystems.ConstrainedLinearControlMap","text":"ConstrainedLinearControlMap\n\nA linear control map with state and input constraints,\n\n    (x u)  Ax + Bu x  mathcalX u  mathcalU\n\nFields\n\nA – matrix\nB – matrix\nX – state constraints\nU – input constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.AffineControlMap","page":"Types","title":"MathematicalSystems.AffineControlMap","text":"AffineControlMap\n\nAn affine control map,\n\n    (x u)  Ax + Bu + c\n\nFields\n\nA – matrix\nB – matrix\nc – vector\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedAffineControlMap","page":"Types","title":"MathematicalSystems.ConstrainedAffineControlMap","text":"ConstrainedAffineControlMap\n\nAn affine control map with state and input constraints,\n\n    (x u)  Ax + Bu + c x  mathcalX u  mathcalU\n\nFields\n\nA – matrix\nB – matrix\nc – vector\nX – state constraints\nU – input constraints\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ResetMap","page":"Types","title":"MathematicalSystems.ResetMap","text":"ResetMap\n\nA reset map,\n\n    x  R(x)\n\nsuch that a subset of the variables is given a specified value, and the rest are unchanged.\n\nFields\n\ndim  – dimension\ndict – dictionary whose keys are the indices of the variables that are reset,           and whose values are the new values\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.ConstrainedResetMap","page":"Types","title":"MathematicalSystems.ConstrainedResetMap","text":"ConstrainedResetMap\n\nA reset map with state constraints of the form:\n\n    x  R(x) x  mathcalX\n\nsuch that the specified variables are assigned a given value, and the remaining variables are unchanged.\n\nFields\n\ndim  – dimension\nX    – state constraints\ndict – dictionary whose keys are the indices of the variables that are           reset, and whose values are the new values\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Macros-1","page":"Types","title":"Macros","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"@map","category":"page"},{"location":"lib/types/#MathematicalSystems.@map","page":"Types","title":"MathematicalSystems.@map","text":"map(ex, args)\n\nReturn an instance of the map type corresponding to the given expression.\n\nInput\n\nex   – an expression defining the map, in the form of an anonymous function\nargs – additional optional arguments\n\nOutput\n\nA map that best matches the given expression.\n\nExamples\n\nLet us first create a linear map using this macro:\n\njulia> @map x -> [1 0; 0 0]*x\nLinearMap{Int64,Array{Int64,2}}([1 0; 0 0])\n\nWe can create an affine system as well:\n\njulia> @map x -> [1 0; 0 0]*x + [2, 0]\nAffineMap{Int64,Array{Int64,2},Array{Int64,1}}([1 0; 0 0], [2, 0])\n\nAdditional arguments can be passed to @map using the function-call form, i.e. separating the arguments by commas, and using parentheses around the macro call. For example, an identity map of dimension 5 can be defined as:\n\njulia> @map(x -> x, dim=5)\nIdentityMap(5)\n\nA state constraint on such map can be specified passing the additional argument x ∈ X.\n\nAn identity map can alternatively be created by giving a the size of the identity matrix as I(n), for example:\n\njulia> @map x -> I(5)*x\nIdentityMap(5)\n\n\n\n\n\n","category":"macro"},{"location":"lib/types/#Systems-with-output-1","page":"Types","title":"Systems with output","text":"","category":"section"},{"location":"lib/types/#","page":"Types","title":"Types","text":"SystemWithOutput\nLinearTimeInvariantSystem\nLTISystem","category":"page"},{"location":"lib/types/#MathematicalSystems.SystemWithOutput","page":"Types","title":"MathematicalSystems.SystemWithOutput","text":"SystemWithOutput{ST<:AbstractSystem, MT<:AbstractMap}\n\nParametric composite type for systems with outputs. It is parameterized in the system's type (ST) and in the map's type (MT).\n\nFields\n\ns         – system of type ST\noutputmap – output map of type MT\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#MathematicalSystems.LinearTimeInvariantSystem","page":"Types","title":"MathematicalSystems.LinearTimeInvariantSystem","text":"LinearTimeInvariantSystem(A, B, C, D)\n\nA linear time-invariant system with of the form\n\nx = Ax + Bu\ny = Cx + Du\n\nInput\n\nA – matrix\nB – matrix\nC – matrix\nD – matrix\n\nOutput\n\nA system with output such that the system is a linear control continuous system and the output map is a linear control map.\n\n\n\n\n\nLinearTimeInvariantSystem(A, B, C, D, X, U)\n\nA linear time-invariant system with state and input constraints of the form\n\nx = Ax + Bu\ny = Cx + Du\n\nwhere x(t)  X and u(t)  U for all t.\n\nInput\n\nA – matrix\nB – matrix\nC – matrix\nD – matrix\nX – state constraints\nU – input constraints\n\nOutput\n\nA system with output such that the system is a constrained linear control continuous system and the output map is a constrained linear control map.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#MathematicalSystems.LTISystem","page":"Types","title":"MathematicalSystems.LTISystem","text":"LTISystem\n\nLTISystem is an alias for LinearTimeInvariantSystem.\n\n\n\n\n\n","category":"function"},{"location":"#MathematicalSystems.jl-1","page":"Home","title":"MathematicalSystems.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DocTestFilters = [r\"[0-9\\.]+ seconds \\(.*\\)\"]","category":"page"},{"location":"#","page":"Home","title":"Home","text":"MathematicalSystems is a Julia package for mathematical systems interfaces.","category":"page"},{"location":"#Features-1","page":"Home","title":"Features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Generic and flexible systems definitions, while being fast and type stable.\nTypes for mathematical systems modeling: continuous, discrete, controlled, linear algebraic, etc.\nIterator interfaces to handle constant or time-varying inputs.","category":"page"},{"location":"#Library-Outline-1","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"lib/types.md\",\n    \"lib/methods.md\",\n    \"lib/internals.md\"\n]\nDepth = 2","category":"page"},{"location":"lib/methods/#Methods-1","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"lib/methods/#","page":"Methods","title":"Methods","text":"This section describes systems methods implemented in MathematicalSystems.jl.","category":"page"},{"location":"lib/methods/#","page":"Methods","title":"Methods","text":"Pages = [\"methods.md\"]\nDepth = 3","category":"page"},{"location":"lib/methods/#","page":"Methods","title":"Methods","text":"CurrentModule = MathematicalSystems\nDocTestSetup = quote\n    using MathematicalSystems\nend","category":"page"},{"location":"lib/methods/#States-1","page":"Methods","title":"States","text":"","category":"section"},{"location":"lib/methods/#","page":"Methods","title":"Methods","text":"statedim\nstateset","category":"page"},{"location":"lib/methods/#MathematicalSystems.statedim","page":"Methods","title":"MathematicalSystems.statedim","text":"statedim(s::AbstractSystem)\n\nReturns the dimension of the state space of system s.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#MathematicalSystems.stateset","page":"Methods","title":"MathematicalSystems.stateset","text":"stateset(s::AbstractSystem)\n\nReturns the set of allowed states of system s.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#Inputs-1","page":"Methods","title":"Inputs","text":"","category":"section"},{"location":"lib/methods/#","page":"Methods","title":"Methods","text":"inputdim\ninputset\nnextinput","category":"page"},{"location":"lib/methods/#MathematicalSystems.inputdim","page":"Methods","title":"MathematicalSystems.inputdim","text":"inputdim(s::AbstractSystem)\n\nReturns the dimension of the input space of system s.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#MathematicalSystems.inputset","page":"Methods","title":"MathematicalSystems.inputset","text":"inputset(s::AbstractSystem)\n\nReturns the set of allowed inputs of system s.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#MathematicalSystems.nextinput","page":"Methods","title":"MathematicalSystems.nextinput","text":"nextinput(input::ConstantInput, n::Int=1)\n\nReturns the first n elements of this input.\n\nInput\n\ninput – a constant input\nn     – (optional, default: 1) the number of desired elements\n\nOutput\n\nA repeated iterator that generates n equal samples of this input.\n\n\n\n\n\nnextinput(input::VaryingInput, n::Int=1)\n\nReturns the first n elements of this input.\n\nInput\n\ninput – varying input\nn     – (optional, default: 1) number of desired elements\n\nOutput\n\nAn iterator of type Base.Iterators.Take that represents at most the first n elements of this input.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#Output-1","page":"Methods","title":"Output","text":"","category":"section"},{"location":"lib/methods/#","page":"Methods","title":"Methods","text":"outputdim\noutputmap","category":"page"},{"location":"lib/methods/#MathematicalSystems.outputdim","page":"Methods","title":"MathematicalSystems.outputdim","text":"outputdim(m::AbstractMap)\n\nReturns the dimension of the output space of the map m.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#MathematicalSystems.outputmap","page":"Methods","title":"MathematicalSystems.outputmap","text":"outputmap(s::SystemWithOutput)\n\nReturns the output map of a system with output.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#Traits-1","page":"Methods","title":"Traits","text":"","category":"section"},{"location":"lib/methods/#","page":"Methods","title":"Methods","text":"islinear(::AbstractSystem)\nislinear(::AbstractMap)\nisaffine(::AbstractSystem)\nispolynomial(::AbstractSystem)\nisaffine(::AbstractMap)\nisnoisy(::AbstractSystem)\niscontrolled(::AbstractSystem)\nisconstrained(::AbstractSystem)\nstate_matrix(::AbstractSystem)\ninput_matrix(::AbstractSystem)\nnoise_matrix(::AbstractSystem)\naffine_term(::AbstractSystem)","category":"page"},{"location":"lib/methods/#MathematicalSystems.islinear-Tuple{AbstractSystem}","page":"Methods","title":"MathematicalSystems.islinear","text":"islinear(s::AbstractSystem)\n\nSpecifies if the dynamics of system s is specified by linear equations.\n\nNotes\n\nWe adopt the notion from [Section 2.7, 1]. For example, the system with inputs x = f(t x u) = A x + B u is linear, since the function f(t  ) is linear in (x u) for each t  mathbbR. On the other hand, x = f(t x u) = A x + B u + c is affine but not linear, since it is not linear in (x u).\n\nThe result of this function only depends on the system type, not the value, and can also be applied to typeof(s). So, if a system type allows an instance that is not linear, it returns false by default. For example, polynomial systems can be nonlinear; hence islinear returns false.\n\n[1] Sontag, Eduardo D. Mathematical control theory: deterministic finite dimensional systems. Vol. 6. Springer Science & Business Media, 2013.\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#MathematicalSystems.islinear-Tuple{AbstractMap}","page":"Methods","title":"MathematicalSystems.islinear","text":"islinear(m::AbstractMap)\n\nSpecifies if the map m is linear or not.\n\nNotes\n\nA map is linear if it preserves the operations of scalar multiplication and vector addition.\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#MathematicalSystems.isaffine-Tuple{AbstractSystem}","page":"Methods","title":"MathematicalSystems.isaffine","text":"isaffine(s::AbstractSystem)\n\nSpecifies if the dynamics of system s is specified by affine equations.\n\nNotes\n\nAn affine system is the composition of a linear system and a translation. See islinear(::AbstractSystem) for the notion of linear system adopted in this library.\n\nThe result of this function only depends on the system type, not the value, and can also be applied to typeof(s). So, if a system type allows an instance that is not affine, it returns false by default. For example, polynomial systems can be nonlinear; hence isaffine is false.\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#MathematicalSystems.ispolynomial-Tuple{AbstractSystem}","page":"Methods","title":"MathematicalSystems.ispolynomial","text":"ispolynomial(s::AbstractSystem)\n\nSpecifies if the dynamics of system s is specified by polynomial equations.\n\nThe result of this function only depends on the system type, not the value, and can also be applied to typeof(s). Hence, e.g. a LinearContinuousSystem is not considered to be of polynomial type.\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#MathematicalSystems.isaffine-Tuple{AbstractMap}","page":"Methods","title":"MathematicalSystems.isaffine","text":"isaffine(m::AbstractMap)\n\nSpecifies if the map m is affine or not.\n\nNotes\n\nAn affine map is the composition of a linear map and a translation. See also islinear(::AbstractMap).\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#MathematicalSystems.isnoisy-Tuple{AbstractSystem}","page":"Methods","title":"MathematicalSystems.isnoisy","text":"isnoisy(s::AbstractSystem)\n\nDetermines if the dynamics of system s contains a noise term w.\n\nThe result of this function only depends on the system type, not the value, and can also be applied to typeof(s).\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#MathematicalSystems.iscontrolled-Tuple{AbstractSystem}","page":"Methods","title":"MathematicalSystems.iscontrolled","text":"iscontrolled(s::AbstractSystem)\n\nDetermines if the dynamics of system s contains a control input u.\n\nThe result of this function only depends on the system type, not the value, and can also be applied to typeof(s).\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#MathematicalSystems.isconstrained-Tuple{AbstractSystem}","page":"Methods","title":"MathematicalSystems.isconstrained","text":"isconstrained(s::AbstractSystem)\n\nDetermines if the system s has constraints on the state, input and noise, respectively (those that are available).\n\nThe result of this function only depends on the system type, not the value, and can also be applied to typeof(s).\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#MathematicalSystems.state_matrix-Tuple{AbstractSystem}","page":"Methods","title":"MathematicalSystems.state_matrix","text":"state_matrix(::AbstractSystem)\n\nReturn the state matrix of an affine system.\n\nNotes\n\nThe state matrix is the matrix proportional to the state, e.g. the matrix A in the linear continuous system x = Ax.\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#MathematicalSystems.input_matrix-Tuple{AbstractSystem}","page":"Methods","title":"MathematicalSystems.input_matrix","text":"input_matrix(::AbstractSystem)\n\nReturn the input matrix of a system with linear input.\n\nNotes\n\nThe input matrix is the matrix proportional to the input, e.g. the matrix B in the linear continuous system with input, x = Ax + Bu.\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#MathematicalSystems.noise_matrix-Tuple{AbstractSystem}","page":"Methods","title":"MathematicalSystems.noise_matrix","text":"noise_matrix(::AbstractSystem)\n\nReturn the noise matrix of a system with linear noise.\n\nNotes\n\nThe noise matrix is the matrix proportional to the noise, e.g. the matrix D in the linear system with noise, x = Ax + Dw.\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#MathematicalSystems.affine_term-Tuple{AbstractSystem}","page":"Methods","title":"MathematicalSystems.affine_term","text":"affine_term(::AbstractSystem)\n\nReturn the affine term in an affine system.\n\nNotes\n\nThe affine term is e.g. the vector c in the affine system x = Ax + c.\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#Maps-1","page":"Methods","title":"Maps","text":"","category":"section"},{"location":"lib/methods/#","page":"Methods","title":"Methods","text":"apply","category":"page"},{"location":"lib/methods/#MathematicalSystems.apply","page":"Methods","title":"MathematicalSystems.apply","text":"apply(m::AbstractMap, args...)\n\nApply the rule specified by the map to the given arguments.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#Successor-1","page":"Methods","title":"Successor","text":"","category":"section"},{"location":"lib/methods/#","page":"Methods","title":"Methods","text":"successor","category":"page"},{"location":"lib/methods/#MathematicalSystems.successor","page":"Methods","title":"MathematicalSystems.successor","text":"successor(system::DiscreteIdentitySystem, x::AbstractVector)\n\nReturn the successor state of a DiscreteIdentitySystem.\n\nInput\n\nsystem – DiscreteIdentitySystem\nx      – state (it should be any vector type)\n\nOutput\n\nThe same state x.\n\n\n\n\n\nsuccessor(system::ConstrainedDiscreteIdentitySystem, x::AbstractVector;\n          [check_constraints]=true)\n\nReturn the successor state of a ConstrainedDiscreteIdentitySystem.\n\nInput\n\nsystem            – ConstrainedDiscreteIdentitySystem\nx                 – state (it should be any vector type)\ncheck_constraints – (optional, default: true) check if the state belongs to                        the state set\n\nOutput\n\nThe same state x.\n\n\n\n\n\nsuccessor(system::LinearDiscreteSystem, x::AbstractVector)\n\nReturn the successor state of a LinearDiscreteSystem.\n\nInput\n\nsystem – LinearDiscreteSystem\nx      – state (it should be any vector type)\n\nOutput\n\nThe result of applying the system to x.\n\n\n\n\n\nsuccessor(system::AffineDiscreteSystem, x::AbstractVector)\n\nReturn the successor state of a AffineDiscreteSystem.\n\nInput\n\nsystem – AffineDiscreteSystem\nx      – state (it should be any vector type)\n\nOutput\n\nThe result of applying the system to x.\n\n\n\n\n\nsuccessor(system::LinearControlDiscreteSystem, x::AbstractVector, u::AbstractVector)\n\nReturn the successor state of a LinearControlDiscreteSystem.\n\nInput\n\nsystem – LinearControlDiscreteSystem\nx      – state (it should be any vector type)\nu      – input (it should be any vector type)\n\nOutput\n\nThe result of applying the system to x, with input u.\n\n\n\n\n\nsuccessor(system::ConstrainedLinearDiscreteSystem, x::AbstractVector;\n          [check_constraints]=true)\n\nReturn the successor state of a ConstrainedLinearDiscreteSystem.\n\nInput\n\nsystem            – ConstrainedLinearDiscreteSystem\nx                 – state (it should be any vector type)\ncheck_constraints – (optional, default: true) check if the state belongs to                        the state set\n\nOutput\n\nThe result of applying the system to x.\n\n\n\n\n\nsuccessor(system::ConstrainedAffineDiscreteSystem, x::AbstractVector;\n          [check_constraints])\n\nReturn the successor state of a ConstrainedAffineDiscreteSystem.\n\nInput\n\nsystem            – ConstrainedAffineDiscreteSystem\nx                 – state (it should be any vector type)\ncheck_constraints – (optional, default: true) check if the state belongs to                        the state set\n\nOutput\n\nThe result of applying the system to x.\n\n\n\n\n\nsuccessor(system::ConstrainedLinearControlDiscreteSystem, x::AbstractVector,\n          u::AbstractVector; [check_constraints]=true)\n\nReturn the successor state of a ConstrainedLinearControlDiscreteSystem.\n\nInput\n\nsystem            – ConstrainedLinearControlDiscreteSystem\nx                 – state (it should be any vector type)\nu                 – input (it should be any vector type)\ncheck_constraints – (optional, default: true) check if the state (resp. input)                        belongs to the state set (resp. input set)\n\nOutput\n\nThe result of applying the system to x, with input u.\n\n\n\n\n\nsuccessor(system::ConstrainedAffineControlDiscreteSystem, x::AbstractVector,\n          u::AbstractVector; [check_constraints]=true)\n\nReturn the successor state of a ConstrainedAffineControlDiscreteSystem.\n\nInput\n\nsystem            – ConstrainedAffineControlDiscreteSystem\nx                 – state (it should be any vector type)\nu                 – input (it should be any vector type)\ncheck_constraints – (optional, default: true) check if the state (resp. input)                        belongs to the state set (resp. input set)\n\nOutput\n\nThe result of applying the system to x, with input u.\n\n\n\n\n\nsuccessor(system::BlackBoxDiscreteSystem, x::AbstractVector)\n\nReturn the successor state of a BlackBoxDiscreteSystem.\n\nInput\n\nsystem – BlackBoxDiscreteSystem\nx      – state (it should be any vector type)\n\nOutput\n\nThe result of applying the system to x.\n\n\n\n\n\nsuccessor(system::ConstrainedBlackBoxDiscreteSystem, x::AbstractVector;\n          [check_constraints]=true)\n\nReturn the successor state of a ConstrainedBlackBoxDiscreteSystem.\n\nInput\n\nsystem            – ConstrainedBlackBoxDiscreteSystem\nx                 – state (it should be any vector type)\ncheck_constraints – (optional, default: true) check if the state belongs to                        the state set\n\nOutput\n\nThe result of applying the system to x.\n\n\n\n\n\nsuccessor(system::ConstrainedBlackBoxControlDiscreteSystem, x::AbstractVector,\n          u::AbstractVector; [check_constraints]=true)\n\nReturn the successor state of a ConstrainedBlackBoxControlDiscreteSystem.\n\nInput\n\nsystem            – ConstrainedBlackBoxControlDiscreteSystem\nx                 – state (it should be any vector type)\nu                 – input (it should be any vector type)\ncheck_constraints – (optional, default: true) check if the state belongs to                        the state set\n\nOutput\n\nThe result of applying the system to x, with input u.\n\n\n\n\n\nsuccessor(system::NoisyConstrainedLinearDiscreteSystem, x::AbstractVector,\n          w::AbstractVector; [check_constraints]=true)\n\nReturn the successor state of a NoisyConstrainedLinearDiscreteSystem.\n\nInput\n\nsystem            – NoisyConstrainedLinearDiscreteSystem\nx                 – state (it should be any vector type)\nw                 – noise (it should be any vector type)\ncheck_constraints – (optional, default: true) check if the state belongs to                        the state set\n\nOutput\n\nThe result of applying the system to x, with noise w.\n\n\n\n\n\nsuccessor(system::NoisyConstrainedLinearControlDiscreteSystem,\n          x::AbstractVector, u::AbstractVector, w::AbstractVector; [check_constraints]=true)\n\nReturn the successor state of a NoisyConstrainedLinearControlDiscreteSystem.\n\nInput\n\nsystem            – NoisyConstrainedLinearControlDiscreteSystem\nx                 – state (it should be any vector type)\nu                 – input (it should be any vector type)\nw                 – noise (it should be any vector type)\ncheck_constraints – (optional, default: true) check if the state (resp. input)                        belongs to the state set (resp. input set)\n\nOutput\n\nThe result of applying the system to x, with input u and noise w.\n\n\n\n\n\nsuccessor(system::NoisyConstrainedAffineControlDiscreteSystem, x::AbstractVector,\n          u::AbstractVector; [check_constraints]=true)\n\nReturn the successor state of a NoisyConstrainedAffineControlDiscreteSystem.\n\nInput\n\nsystem            – NoisyConstrainedAffineControlDiscreteSystem\nx                 – state (it should be any vector type)\nu                 – input (it should be any vector type)\nw                 – noise (it should be any vector type)\ncheck_constraints – (optional, default: true) check if the state (resp. input)                        belongs to the state set (resp. input set)\n\nOutput\n\nThe result of applying the system to x, with input u and noise w.\n\n\n\n\n\nsuccessor(system::NoisyConstrainedBlackBoxControlDiscreteSystem, x::AbstractVector,\n          u::AbstractVector, w::AbstractVector; [check_constraints]=true)\n\nReturn the successor state of a NoisyConstrainedBlackBoxControlDiscreteSystem.\n\nInput\n\nsystem            – NoisyConstrainedBlackBoxControlDiscreteSystem\nx                 – state (it should be any vector type)\nu                 – input (it should be any vector type)\nw                 – noise (it should be any vector type)\ncheck_constraints – (optional, default: true) check if the state belongs to                        the state set\n\nOutput\n\nThe result of applying the system to x, with input u and noise w.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#Discretization-1","page":"Methods","title":"Discretization","text":"","category":"section"},{"location":"lib/methods/#","page":"Methods","title":"Methods","text":"discretize","category":"page"},{"location":"lib/methods/#MathematicalSystems.discretize","page":"Methods","title":"MathematicalSystems.discretize","text":"discretize(system::AbstractContinuousSystem, ΔT::Real,\n           algorithm::AbstractDiscretizationAlgorithm=ExactDiscretization(),\n           constructor=_default_complementary_constructor(system))\n\nDiscretization of a isaffine AbstractContinuousSystem to a AbstractDiscreteSystem with sampling time ΔT using the discretization method algorithm.\n\nInput\n\nsystem      – an affine continuous system\nΔT          – sampling time\nalgorithm   – (optional, default: ExactDiscretization()) discretization algorithm\nconstructor – (optional, default: _default_complementary_constructor(system)) construction method\n\nOutput\n\nReturns a discretization of the input system system with discretization method algorithm and sampling time ΔT.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#Internal-Methods-1","page":"Methods","title":"Internal Methods","text":"","category":"section"},{"location":"lib/methods/#","page":"Methods","title":"Methods","text":"_discretize\ntypename(::AbstractSystem)\n_complementary_type(::Type{<:AbstractSystem})","category":"page"},{"location":"lib/methods/#MathematicalSystems._discretize","page":"Methods","title":"MathematicalSystems._discretize","text":"_discretize(::AbstractDiscretizationAlgorithm, ΔT::Real\n            A::AbstractMatrix, B::AbstractMatrix, c::AbstractVector, D::AbstractMatrix)\n\nImplementation of the discretization algorithm defined by the first input argument with sampling time ΔT.\n\nInput\n\n``   – discretization algorithm, used for dispatch\nΔT – sampling time\nA  – state matrix\nB  – input matrix\nc  – vector\nD  – noise matrix\n\nOutput\n\nReturns a vector containing the discretized input arguments A, B, c and D.\n\nNotes\n\nSee discretize for more details.\n\n\n\n\n\n_discretize(A::AbstractMatrix, ΔT::Real; algorithm=:exact)\n\nDiscretize the state matrix A with sampling time ΔT and discretization method algorithm.\n\nInput\n\nA         – state matrix\nΔT        – sampling time\nalgorithm – (optional, default: :exact) discretization algorithm\n\nOutput\n\nReturns a vector containing the discretized input argument A.\n\nNotes\n\nSee discretize for more details.\n\n\n\n\n\n_discretize(algorithm::AbstractDiscretizationAlgorithm, ΔT::Real,\n            A::AbstractMatrix, B::AbstractMatrix)\n\nDiscretize the state matrix A and input or noise matrix B with sampling time ΔT and discretization method algorithm.\n\nInput\n\nalgorithm – discretization algorithm\nΔT        – sampling time\nA         – state matrix\nB         – input or noise matrix\n\nOutput\n\nReturns a vector containing the discretized input arguments A and B.\n\nNotes\n\nThis method signature with two arguments of type AbstractMatrix works both for a noisy system with fields (:A,:D) and a controlled system with fields (:A,:B).\n\nSee discretize for more details.\n\n\n\n\n\n_discretize(algorithm::AbstractDiscretizationAlgorithm, ΔT::Real,\n            A::AbstractMatrix,c::AbstractVector)\n\nDiscretize the state matrix A and vector c with sampling time ΔT and discretization method algorithm.\n\nInput\n\nalgorithm – discretization algorithm\nΔT        – sampling time\nA         – state matrix\nc         – vector\n\nOutput\n\nReturns a vector containing the discretized input arguments A and c.\n\nNotes\n\nSee discretize for more details.\n\n\n\n\n\n_discretize(algorithm::AbstractDiscretizationAlgorithm, ΔT::Real,\n            A::AbstractMatrix, B::AbstractMatrix, c::AbstractVector)\n\nDiscretize the state matrix A, input matrix B and vector c with sampling time ΔT and discretization method algorithm.\n\nInput\n\nalgorithm – discretization algorithm\nΔT        – sampling time\nA         – state matrix\nB         – input matrix\nc         – vector\n\nOutput\n\nReturns a vector containing the discretized input arguments A, B and c.\n\nNotes\n\nSee discretize for more details.\n\n\n\n\n\n_discretize(algorithm::AbstractDiscretizationAlgorithm, ΔT::Real,\n            A::AbstractMatrix, B::AbstractMatrix, D::AbstractMatrix)\n\nDiscretize the state matrix A, input matrix B and noise matrix C with sampling time ΔT and discretization method algorithm.\n\nInput\n\nalgorithm – discretization algorithm\nΔT        – sampling time\nA         – state matrix\nB         – input matrix\nD         – noise matrix\n\nOutput\n\nReturns a vector containing the discretized input arguments A, B and D.\n\nNotes\n\nSee discretize for more details.\n\n\n\n\n\n","category":"function"},{"location":"lib/methods/#MathematicalSystems.typename-Tuple{AbstractSystem}","page":"Methods","title":"MathematicalSystems.typename","text":"typename(system::AbstractSystem)\n\nReturns the base type of system without parameter information.\n\nInput\n\nsystem – AbstractSystem\n\nOutput\n\nThe base type of system.\n\n\n\n\n\n","category":"method"},{"location":"lib/methods/#MathematicalSystems._complementary_type-Tuple{Type{#s3} where #s3<:AbstractSystem}","page":"Methods","title":"MathematicalSystems._complementary_type","text":"_complementary_type(system_type::Type{<:AbstractSystem})\n\nReturn the complementary type of a system type system_type.\n\nInput\n\nsystem_type – type of AbstractSystem\n\nOuput\n\nReturn complementary type of system_type.\n\nNotes\n\nThere are two main subclasses of abstract types: continuous types and discrete types. A complementary type of system_type has the same fields as system_type but belongs to the other subclass, e.g. for a LinearContinuousSystem which is a subtype of AbstractContinuousSystem and has the field :A, the subtype of AbstractDiscreteSystem with the field :A, i.e. LinearDiscreteSystem, is returned.\n\nTo get the complementary type of system type, use _complementary_type(typename(system)).\n\n\n\n\n\n","category":"method"}]
}
