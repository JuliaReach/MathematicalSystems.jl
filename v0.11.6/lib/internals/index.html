<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals · MathematicalSystems.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MathematicalSystems.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../types/">Types</a></li><li><a class="toctext" href="../methods/">Methods</a></li><li class="current"><a class="toctext" href>Internals</a><ul class="internal"><li><a class="toctext" href="#Expression-handling-1">Expression handling</a></li><li><a class="toctext" href="#Querying-expressions-1">Querying expressions</a></li><li><a class="toctext" href="#Evaluation-of-AbstractSystem-at-given-state-1">Evaluation of AbstractSystem at given state</a></li><li><a class="toctext" href="#Naming-convention-for-systems&#39;-fields-1">Naming convention for systems&#39; fields</a></li></ul></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Internals</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/MathematicalSystems.jl/blob/master/docs/src/lib/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Internals</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Internals-1" href="#Internals-1">Internals</a></h1><p>This section describes functions that are internal to the library.</p><ul><li><a href="#Internals-1">Internals</a></li><ul><li><a href="#Expression-handling-1">Expression handling</a></li><li><a href="#Querying-expressions-1">Querying expressions</a></li><li><a href="#Evaluation-of-AbstractSystem-at-given-state-1">Evaluation of AbstractSystem at given state</a></li><li><a href="#Naming-convention-for-systems&#39;-fields-1">Naming convention for systems&#39; fields</a></li></ul></ul><h2><a class="nav-anchor" id="Expression-handling-1" href="#Expression-handling-1">Expression handling</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathematicalSystems._corresponding_type" href="#MathematicalSystems._corresponding_type"><code>MathematicalSystems._corresponding_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">_corresponding_type(AT::Type{&lt;:AbstractSystem}, fields::Tuple)</code></pre><p>Return the system type whose field names match those in <code>fields</code>.</p><p><strong>Input</strong></p><ul><li><code>AT</code>     – abstract system type, which can be either <code>AbstractContinuousSystem</code>             or <code>AbstractDiscreSystem</code></li><li><code>fields</code> – tuple of field names</li></ul><p><strong>Output</strong></p><p>The system type (either discrete or continous, depending on <code>AT</code>) whose fields names correspond to those in <code>fields</code>, or an error if the <code>fields</code> do not match any known system type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using MathematicalSystems: _corresponding_type

julia&gt; _corresponding_type(AbstractContinuousSystem, ((:A),))
LinearContinuousSystem

julia&gt; _corresponding_type(AbstractContinuousSystem, ((:A), (:B), (:X), (:U)))
ConstrainedLinearControlContinuousSystem</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/MathematicalSystems.jl/blob/5d8572c08e418ef720e45089cb837c67577ab1d0/src/macros.jl#L129-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathematicalSystems._capture_dim" href="#MathematicalSystems._capture_dim"><code>MathematicalSystems._capture_dim</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">_capture_dim(expr)</code></pre><p>Return the tuple containing the dimension(s) in <code>expr</code>.</p><p><strong>Input</strong></p><ul><li><p><code>expr</code> – symbolic expression that can be of any of the following forms:</p><ul><li><code>:x</code> or <code>:(x)</code> – state dimension</li><li><code>:(x, u)</code>      – state and input dimension</li><li><code>:(x, u, w)</code>   – state, input and noise dimensions</li></ul></li></ul><p><strong>Output</strong></p><ul><li>The scalar <code>x</code> if <code>expr</code> specifies the state dimension.</li><li>The vector <code>[x, u]</code> if <code>expr</code> specifies state and input dimension.</li><li>The vector <code>[x, u, w]</code> if <code>expr</code> specifies state, input and noise dimensions.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/MathematicalSystems.jl/blob/5d8572c08e418ef720e45089cb837c67577ab1d0/src/macros.jl#L170-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathematicalSystems.extract_dyn_equation_parameters" href="#MathematicalSystems.extract_dyn_equation_parameters"><code>MathematicalSystems.extract_dyn_equation_parameters</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">extract_dyn_equation_parameters(equation, state, input, noise, dim, AT)</code></pre><p>Extract the value and field parameter from the dynamic equation <code>equation</code> according to the variable <code>state</code>, <code>input</code> and <code>noise</code>.</p><p>For the right-hand side of the dynamic equation, this function returns a vector of tuples containing some elements from the list</p><ul><li><code>(:A_user, :A)</code></li><li><code>(:B_user, :B)</code></li><li><code>(:c_user, :c)</code></li><li><code>(:D_user, :D)</code></li><li><code>(:f_user, :f)</code></li><li><code>(:statedim_user :statedim)</code></li><li><code>(:inputdim_user :inputdim)</code></li><li><code>(:noisedim_user :noisedim)</code></li></ul><p>and for the left-hand side, it returns either an empty vector <code>Any[]</code> or <code>[(:E_user, :E)]</code> where the first argument of the tuple corresponds to the value and the second argument of the tuple corresponds to the field parameter.</p><p><strong>Input</strong></p><ul><li><code>equation</code> – dynamic equation</li><li><code>state</code>    – state variable</li><li><code>input</code>    – input variable</li><li><code>noise</code>    – noise variable</li><li><code>dim</code>      – dimensionality</li><li><code>AT</code>       – abstract system type</li></ul><p><strong>Output</strong></p><p>Two arrays of tuples containing the value and field parameters for the right-hand and left-hand side of the dynamic equation <code>equation</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/MathematicalSystems.jl/blob/5d8572c08e418ef720e45089cb837c67577ab1d0/src/macros.jl#L364-L397">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathematicalSystems.add_asterisk" href="#MathematicalSystems.add_asterisk"><code>MathematicalSystems.add_asterisk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_asterisk(summand, state::Symbol, input::Symbol, noise::Symbol)</code></pre><p>Checks if expression <code>summand</code> contains <code>state</code>, <code>input</code> or <code>noise</code> at its end. If so, a multiplication expression, e.g. <code>Expr(:call, :*, :A, :x) is created. If not,</code>summand` is returned.</p><p><strong>Input</strong></p><ul><li><code>summand</code> – expressions</li><li><code>state</code>   – state variable</li><li><code>input</code>   – input variable</li><li><code>noise</code>   – noise variable</li></ul><p><strong>Output</strong></p><p>Multiplication expression or symbol.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using MathematicalSystems: add_asterisk

julia&gt; add_asterisk(:(A1*x), :x, :u, :w)
:(A1 * x)

julia&gt; add_asterisk(:(c1), :x, :u, :w)
:c1

julia&gt; add_asterisk(:(Ax1), :x1, :u, :w)
:(A * x1)

julia&gt; add_asterisk(:(Awb), :x1, :u, :wb)
:(A * wb)

julia&gt; add_asterisk(:(A1u), :x, :u, :w)
:(A1 * u)

julia&gt; add_asterisk(:(A1ub), :x, :u, :w)
:A1ub</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/MathematicalSystems.jl/blob/5d8572c08e418ef720e45089cb837c67577ab1d0/src/macros.jl#L461-L502">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.sort" href="#Base.sort"><code>Base.sort</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sort(parameters::Vector, order::Tuple)</code></pre><p>Filter and sort the vector <code>parameters</code> according to <code>order</code>.</p><p><strong>Input</strong></p><ul><li><code>parameters</code> – vector of tuples</li><li><code>order</code>      – tuple of symbols</li></ul><p><strong>Output</strong></p><p>A new vector of tuples corresponding to <code>parameters</code> filtered and sorted according to <code>order</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; parameters= [(:U1, :U), (:X1, :X), (:W1, :W)];

julia&gt; sort(parameters, (:X, :U, :W))
3-element Array{Tuple{Any,Symbol},1}:
 (:X1, :X)
 (:U1, :U)
 (:W1, :W)

julia&gt;  parameters = [(:const, :c), (:A, :A)];

julia&gt; sort(parameters, (:A, :B, :c, :D))
2-element Array{Tuple{Any,Symbol},1}:
 (:A, :A)
 (:const, :c)</code></pre><p><strong>Notes</strong></p><p><code>parameters</code> is a vector that contains tuples whose second element is considered for the sorting according to <code>order</code>.</p><p>If a value of <code>order</code> is not contained in <code>parameters</code>, the corresponding entry of <code>order</code> will be omitted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/MathematicalSystems.jl/blob/5d8572c08e418ef720e45089cb837c67577ab1d0/src/macros.jl#L706-L747">source</a></section><h2><a class="nav-anchor" id="Querying-expressions-1" href="#Querying-expressions-1">Querying expressions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathematicalSystems.is_equation" href="#MathematicalSystems.is_equation"><code>MathematicalSystems.is_equation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">is_equation(expr)</code></pre><p>Return <code>true</code> if the given expression <code>expr</code> corresponds to an equation <code>lhs = rhs</code> and <code>false</code> otherwise. This function just detects the presence of the symbol <code>=</code>.</p><p><strong>Input</strong></p><ul><li><code>expr</code> – expression</li></ul><p><strong>Output</strong></p><p>A <code>Bool</code> indicating whether <code>expr</code> is an equation or not.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/MathematicalSystems.jl/blob/5d8572c08e418ef720e45089cb837c67577ab1d0/src/macros.jl#L206-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathematicalSystems.extract_sum" href="#MathematicalSystems.extract_sum"><code>MathematicalSystems.extract_sum</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">extract_sum(summands, state::Symbol, input::Symbol, noise::Symbol)</code></pre><p>Extract the variable name and field name for every element of <code>summands</code> which corresponds to the elements of the right-hand side of an affine system.</p><p><strong>Input</strong></p><ul><li><code>summands</code> – array of expressions</li><li><code>state</code>    – state variable</li><li><code>input</code>    – input variable</li><li><code>noise</code>    – noise variable</li></ul><p><strong>Output</strong></p><p>Array of tuples of symbols with variable name and field name.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using MathematicalSystems: extract_sum

julia&gt; extract_sum([:(A1*x)], :x, :u, :w)
1-element Array{Tuple{Any,Symbol},1}:
 (:(hcat(A1)), :A)

julia&gt; extract_sum([:(A1*x), :(B1*u), :c], :x, :u, :w)
3-element Array{Tuple{Any,Symbol},1}:
 (:(hcat(A1)), :A)
 (:(hcat(B1)), :B)
 (:(vcat(c)), :c)

julia&gt; extract_sum([:(A1*x7), :( B1*u7), :( B2*w7)], :x7, :u7, :w7)
3-element Array{Tuple{Any,Symbol},1}:
 (:(hcat(A1)), :A)
 (:(hcat(B1)), :B)
 (:(hcat(B2)), :D)</code></pre><p><strong>Notes</strong></p><p>If an element of <code>summands</code> is a multiplication expression <code>lhs*rhs</code>, return <code>lhs</code> as variable name and <code>:A</code> as field name if <code>rhs==state</code>, <code>:B</code> as field name if <code>rhs==input</code> and <code>:D</code> as field name if <code>rhs==noise</code>.</p><p>If an element of <code>summands</code> is a symbol, and not equal to <code>input</code> or <code>noise</code>, the symbol is the variable name and the field name is <code>:c</code>. If it is equal to <code>input</code>, the variable name is a <code>IdentityMultiple(I,state_dim)</code> where <code>state_dim</code> is extracted from the state matrix (i.e. take the symbol <code>lhs</code> of <code>lhs*rhs</code> where <code>rhs==state</code> which corresponds to the state matrix and generate the expression <code>state_dim = size(lhs,1)</code> which is evaluated in the scope where <code>@system</code> is called) and the field name is <code>:B</code>.</p><p>Similiarily, if the element is equal to <code>noise</code>, the variable name is <code>IdentityMultiple(I, state_dim)</code> and the field name is <code>:D</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/MathematicalSystems.jl/blob/5d8572c08e418ef720e45089cb837c67577ab1d0/src/macros.jl#L530-L585">source</a></section><h2><a class="nav-anchor" id="Evaluation-of-AbstractSystem-at-given-state-1" href="#Evaluation-of-AbstractSystem-at-given-state-1">Evaluation of AbstractSystem at given state</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MathematicalSystems._instantiate" href="#MathematicalSystems._instantiate"><code>MathematicalSystems._instantiate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">_instantiate(system::AbstractSystem, x::AbstractVector;
            [check_constraints]=true)</code></pre><p>Return the result of instantiating an <code>AbstractSystem</code> at the current state.</p><p><strong>Input</strong></p><ul><li><code>system</code>            – <code>AbstractSystem</code></li><li><code>x</code>                 – state (it should be any vector type)</li><li><code>check_constraints</code> – (optional, default: <code>true</code>) check if the state belongs to                        the state set</li></ul><p><strong>Output</strong></p><p>The result of applying the system to state <code>x</code>.</p><p><strong>Notes</strong></p><p>The <code>_instantiate</code> method generalizes the <code>successor</code> of an <code>AbstractDiscreteSystem</code> and the <code>vector_field</code> of an <code>AbstractContinuousSystem</code> into a single method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/MathematicalSystems.jl/blob/5d8572c08e418ef720e45089cb837c67577ab1d0/src/instantiate.jl#L28-L49">source</a><div><div><pre><code class="language-none">_instantiate(system::AbstractSystem, x::AbstractVector, u::AbstractVector;
            [check_constraints]=true)</code></pre><p>Return the result of instantiating an <code>AbstractSystem</code> at the current state and applying one input.</p><p><strong>Input</strong></p><ul><li><code>system</code>            – <code>AbstractSystem</code></li><li><code>x</code>                 – state (it should be any vector type)</li><li><code>u</code>                 – input (it should be any vector type) or noise, if <code>system</code>                        is not controlled</li><li><code>check_constraints</code> – (optional, default: <code>true</code>) check if the state belongs to                        the state set</li></ul><p><strong>Output</strong></p><p>The result of applying the system to state <code>x</code> and input <code>u</code>.</p><p><strong>Notes</strong></p><p>If the system is not controlled but noisy, the input <code>u</code> is interpreted as noise.</p><p>The <code>_instantiate</code> method generalizes the <code>successor</code> of an <code>AbstractDiscreteSystem</code> and the <code>vector_field</code> of an <code>AbstractContinuousSystem</code> into a single method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/MathematicalSystems.jl/blob/5d8572c08e418ef720e45089cb837c67577ab1d0/src/instantiate.jl#L71-L97">source</a><div><div><pre><code class="language-none">_instantiate(system::AbstractSystem,
            x::AbstractVector, u::AbstractVector, w::AbstractVector; [check_constraints]=true)</code></pre><p>Return the result of instantiating an <code>AbstractSystem</code> at the current state and applying two inputs to an <code>AbstractSystem</code>.</p><p><strong>Input</strong></p><ul><li><code>system</code>            – <code>AbstractSystem</code></li><li><code>x</code>                 – state (it should be any vector type)</li><li><code>u</code>                 – input (it should be any vector type)</li><li><code>w</code>                 – noise (it should be any vector type)</li><li><code>check_constraints</code> – (optional, default: <code>true</code>) check if the state belongs to                        the state set</li></ul><p><strong>Output</strong></p><p>The result of applying the system to state <code>x</code>, input <code>u</code> and noise <code>w</code>.</p><p><strong>Notes</strong></p><p>The <code>_instantiate</code> method generalizes the <code>successor</code> of an <code>AbstractDiscreteSystem</code> and the <code>vector_field</code> of an <code>AbstractContinuousSystem</code> into a single method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/MathematicalSystems.jl/blob/5d8572c08e418ef720e45089cb837c67577ab1d0/src/instantiate.jl#L136-L160">source</a></section><h2><a class="nav-anchor" id="Naming-convention-for-systems&#39;-fields-1" href="#Naming-convention-for-systems&#39;-fields-1">Naming convention for systems&#39; fields</a></h2><p>Systems&#39; fields should be accessed externally by their respective getter functions. Internally to the library, the following naming conventions are used.</p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Description</th><th style="text-align: right">Getter function</th></tr><tr><td style="text-align: right"><code>A</code></td><td style="text-align: right">state matrix</td><td style="text-align: right"><code>state_matrix</code></td></tr><tr><td style="text-align: right"><code>B</code></td><td style="text-align: right">input matrix</td><td style="text-align: right"><code>input_matrix</code></td></tr><tr><td style="text-align: right"><code>c</code></td><td style="text-align: right">affine term</td><td style="text-align: right"><code>affine_term</code></td></tr><tr><td style="text-align: right"><code>D</code></td><td style="text-align: right">noise matrix</td><td style="text-align: right"><code>noise_matrix</code></td></tr><tr><td style="text-align: right"><code>X</code></td><td style="text-align: right">state constraints</td><td style="text-align: right"><code>stateset</code></td></tr><tr><td style="text-align: right"><code>U</code></td><td style="text-align: right">input constraints</td><td style="text-align: right"><code>inputset</code></td></tr><tr><td style="text-align: right"><code>W</code></td><td style="text-align: right">disturbance set</td><td style="text-align: right"><code>noiseset</code></td></tr></table><footer><hr/><a class="previous" href="../methods/"><span class="direction">Previous</span><span class="title">Methods</span></a><a class="next" href="../../about/"><span class="direction">Next</span><span class="title">About</span></a></footer></article></body></html>
